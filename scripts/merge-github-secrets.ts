#!/usr/bin/env tsx

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

import JSON5 from "json5";

type SecretGroup = {
  strings?: Record<string, string>;
  files?: Record<string, string>;
};

type SecretsFile = SecretGroup;

export type MergeInput = {
  label: string;
  relativePath: string;
  optional?: boolean;
};

export interface MergeOptions {
  rootDir?: string;
  output?: string;
  inputs?: MergeInput[];
  quiet?: boolean;
}

export interface MergeResult {
  outputPath: string;
  mergedFiles: string[];
}

const DEFAULT_OUTPUT = ".github-secrets.private.json5";

const DEFAULT_INPUTS: MergeInput[] = [
  {
    label: "base",
    relativePath: ".github-secrets.private.json5",
    optional: true,
  },
  { label: "dev", relativePath: ".github-secrets.private.dev.json5" },
  {
    label: "dev (deprecated filename)",
    relativePath: ".github-secrets.dev.private.json5",
    optional: true,
  },
  {
    label: "stage",
    relativePath: ".github-secrets.private.stage.json5",
    optional: true,
  },
  {
    label: "stage (deprecated filename)",
    relativePath: ".github-secrets.stage.private.json5",
    optional: true,
  },
  { label: "prod", relativePath: ".github-secrets.private.prod.json5" },
  {
    label: "prod (deprecated filename)",
    relativePath: ".github-secrets.prod.private.json5",
    optional: true,
  },
];

const normalizeSecrets = (
  raw: SecretsFile | undefined,
): Required<SecretsFile> => {
  if (!raw) return { strings: {}, files: {} };
  if (raw.strings || raw.files) {
    return {
      strings: { ...(raw.strings ?? {}) },
      files: { ...(raw.files ?? {}) },
    };
  }

  // Deprecated schema where keys live at root level (no strings/files wrapper)
  return {
    strings: { ...(raw as Record<string, string>) },
    files: {},
  };
};

export const mergeGithubSecrets = (options: MergeOptions = {}): MergeResult => {
  const rootDir = options.rootDir
    ? path.resolve(options.rootDir)
    : process.cwd();
  const outputPath = path.resolve(rootDir, options.output ?? DEFAULT_OUTPUT);
  const quiet = Boolean(options.quiet);
  const inputs = options.inputs ?? DEFAULT_INPUTS;

  const merged: Required<SecretsFile> = {
    strings: {},
    files: {},
  };

  const mergedFiles: string[] = [];
  const missing: MergeInput[] = [];

  for (const input of inputs) {
    const absolute = path.resolve(rootDir, input.relativePath);
    if (!fs.existsSync(absolute)) {
      missing.push(input);
      continue;
    }

    const raw = fs.readFileSync(absolute, "utf8");
    const parsed = JSON5.parse(raw) as SecretsFile;
    const normalized = normalizeSecrets(parsed);
    merged.strings = { ...merged.strings, ...normalized.strings };
    merged.files = { ...merged.files, ...normalized.files };
    mergedFiles.push(absolute);
    if (!quiet) {
      console.info(
        `ðŸ” merged ${input.label} secrets (${path.relative(rootDir, absolute)})`,
      );
    }
  }

  if (!mergedFiles.length) {
    const labels = inputs.map((i) => i.relativePath).join(", ");
    throw new Error(
      `No secrets files found. Expected at least one of: ${labels}. Did you create the *.private.json5 files?`,
    );
  }

  const headerLines = [
    "// AUTOGENERATED FILE â€” do not edit manually.",
    "// Source files: .github-secrets.private.json5 + .github-secrets.private.<env>.json5 overrides.",
    "// Use 'npm run secrets:bundle' to regenerate after updating per-environment secrets.",
  ];

  const body = `${JSON.stringify(merged, null, 2)}\n`;
  const content = `${headerLines.join("\n")}\n${body}`;

  fs.writeFileSync(outputPath, content, "utf8");

  if (!quiet) {
    console.info(
      `âœ… Wrote bundled secrets â†’ ${path.relative(rootDir, outputPath)}`,
    );
    if (missing.length) {
      const skipped = missing
        .map((m) => `${m.label} (${m.relativePath})`)
        .join(", ");
      console.info(`â„¹ï¸  Skipped missing inputs: ${skipped}`);
    }
  }

  return { outputPath, mergedFiles };
};

const runCli = () => {
  const args = process.argv.slice(2);
  let output: string | undefined;
  let rootDir: string | undefined;
  let quiet = false;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--output" || arg === "-o") {
      output = args[i + 1];
      i += 1;
      continue;
    }
    if (arg === "--root" || arg === "-r") {
      rootDir = args[i + 1];
      i += 1;
      continue;
    }
    if (arg === "--quiet" || arg === "-q") {
      quiet = true;
      continue;
    }
    console.warn(`âš ï¸  Unknown argument ignored: ${arg}`);
  }

  mergeGithubSecrets({ output, rootDir, quiet });
};

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  runCli();
}

export default mergeGithubSecrets;
