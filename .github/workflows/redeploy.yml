# Redeploy Workflow (prod + dev restart & env injection)
name: Redeploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: Which profiles to (re)start
        type: choice
        required: true
        default: both
        options:
          - prod
          - dev
          - both
      start_dev:
        description: Ensure dev containers are up in addition to prod
        type: choice
        required: true
        default: "true"
        options:
          - "true"
          - "false"
      refresh_env:
        description: Regenerate and upload .env files to EC2 (requires secrets)
        type: choice
        required: true
        default: "false"
        options:
          - "true"
          - "false"
      restart_containers:
        description: (Re)start containers on EC2 (docker compose pull/up)
        type: choice
        required: true
        default: "true"
        options:
          - "true"
          - "false"

  workflow_call:
    inputs:
      environment:
        description: Which profiles to (re)start
        type: string
        required: true
        default: both
      start_dev:
        description: Ensure dev containers are up in addition to prod
        type: string
        required: true
        default: "true"
      refresh_env:
        description: Regenerate and upload .env files to EC2 (requires secrets)
        type: string
        required: true
        default: "false"
      restart_containers:
        description: (Re)start containers on EC2 (docker compose pull/up)
        type: string
        required: true
        default: "true"

jobs:
  deploy:
    name: SSH redeploy on EC2
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Prevent overlapping prod/dev redeploys from stepping on each other.
    # Use per-environment concurrency so prod and dev can proceed independently.
    # If environment == 'both', fall back to a single global group.
    concurrency:
      group: "redeploy-${{ inputs.environment == 'both' && 'global' || inputs.environment }}"
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare SSH key
        id: ssh
        env:
          SSH_KEY_PEM: ${{ secrets.EC2_SSH_KEY_PEM }}
          SSH_KEY_ALT: ${{ secrets.EC2_SSH_KEY }}
        run: |
          set -euo pipefail
          CONTENT="${SSH_KEY_PEM:-}"
          if [ -z "$CONTENT" ] && [ -n "${SSH_KEY_ALT:-}" ]; then
            CONTENT="$SSH_KEY_ALT"
          fi
          if [ -z "$CONTENT" ]; then
            echo "Missing SSH key secret: provide EC2_SSH_KEY_PEM or EC2_SSH_KEY" >&2
            exit 1
          fi
          umask 177
          printf "%s" "$CONTENT" > key.pem
          echo "key=key.pem" >> "$GITHUB_OUTPUT"

      - name: Validate required inputs and secrets
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          REFRESH_ENV: ${{ inputs.refresh_env }}
          PROD_MONGODB_URI: ${{ secrets.PROD_MONGODB_URI }}
          PROD_PAYLOAD_SECRET: ${{ secrets.PROD_PAYLOAD_SECRET }}
          PROD_S3_BUCKET: ${{ secrets.PROD_S3_BUCKET }}
          PROD_AWS_REGION: ${{ secrets.PROD_AWS_REGION }}
          DEV_MONGODB_URI: ${{ secrets.DEV_MONGODB_URI }}
          DEV_PAYLOAD_SECRET: ${{ secrets.DEV_PAYLOAD_SECRET }}
          DEV_S3_BUCKET: ${{ secrets.DEV_S3_BUCKET }}
          DEV_AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
        run: |
          set -euo pipefail
          : "${ENVIRONMENT}"
          : "${EC2_HOST}"
          : "${REFRESH_ENV}"
          # Only enforce env-specific secrets for the selected environment(s)
          if [ "$REFRESH_ENV" = "true" ]; then
            case "$ENVIRONMENT" in
              prod)
                : "${PROD_MONGODB_URI}"
                : "${PROD_PAYLOAD_SECRET}"
                : "${PROD_S3_BUCKET}"
                : "${PROD_AWS_REGION}"
                ;;
              dev)
                : "${DEV_MONGODB_URI}"
                : "${DEV_PAYLOAD_SECRET}"
                : "${DEV_S3_BUCKET}"
                : "${DEV_AWS_REGION}"
                ;;
              both)
                : "${PROD_MONGODB_URI}"
                : "${PROD_PAYLOAD_SECRET}"
                : "${PROD_S3_BUCKET}"
                : "${PROD_AWS_REGION}"
                : "${DEV_MONGODB_URI}"
                : "${DEV_PAYLOAD_SECRET}"
                : "${DEV_S3_BUCKET}"
                : "${DEV_AWS_REGION}"
                ;;
            esac
          fi

      - name: Generate env files (in runner temp)
        id: genenv
        if: ${{ inputs.refresh_env == 'true' || inputs.refresh_env == true }}
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          # Common
          S3_REGION: ${{ secrets.S3_REGION }}
          PUBLIC_PROJECTS_BUCKET: ${{ secrets.PUBLIC_PROJECTS_BUCKET }}
          NDA_PROJECTS_BUCKET: ${{ secrets.NDA_PROJECTS_BUCKET }}
          SECURITY_TXT_EXPIRES: ${{ secrets.SECURITY_TXT_EXPIRES }}
          # Unified env-guard definition lists (per-profile)
          PROD_REQUIRED_ENVIRONMENT_VARIABLES: ${{ secrets.PROD_REQUIRED_ENVIRONMENT_VARIABLES }}
          DEV_REQUIRED_ENVIRONMENT_VARIABLES: ${{ secrets.DEV_REQUIRED_ENVIRONMENT_VARIABLES }}
          # Prod
          PROD_MONGODB_URI: ${{ secrets.PROD_MONGODB_URI }}
          PROD_PAYLOAD_SECRET: ${{ secrets.PROD_PAYLOAD_SECRET }}
          PROD_S3_BUCKET: ${{ secrets.PROD_S3_BUCKET }}
          PROD_AWS_REGION: ${{ secrets.PROD_AWS_REGION }}
          PROD_FRONTEND_URL: ${{ secrets.PROD_FRONTEND_URL }}
          PROD_BACKEND_INTERNAL_URL: ${{ secrets.PROD_BACKEND_INTERNAL_URL }}
          PROD_SES_FROM_EMAIL: ${{ secrets.PROD_SES_FROM_EMAIL }}
          PROD_SES_TO_EMAIL: ${{ secrets.PROD_SES_TO_EMAIL }}
          # Dev
          DEV_MONGODB_URI: ${{ secrets.DEV_MONGODB_URI }}
          DEV_PAYLOAD_SECRET: ${{ secrets.DEV_PAYLOAD_SECRET }}
          DEV_S3_BUCKET: ${{ secrets.DEV_S3_BUCKET }}
          DEV_AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
          DEV_FRONTEND_URL: ${{ secrets.DEV_FRONTEND_URL }}
          DEV_BACKEND_INTERNAL_URL: ${{ secrets.DEV_BACKEND_INTERNAL_URL }}
          DEV_SES_FROM_EMAIL: ${{ secrets.DEV_SES_FROM_EMAIL }}
          DEV_SES_TO_EMAIL: ${{ secrets.DEV_SES_TO_EMAIL }}
        run: bash deploy/scripts/actions/generate-env-files.sh

      - name: Upload env files to EC2
        if: ${{ inputs.refresh_env == 'true' || inputs.refresh_env == true }}
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          OUT_DIR: ${{ steps.genenv.outputs.dir }}
          SSH_OPTS: -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -o ServerAliveInterval=5 -o ServerAliveCountMax=2 -o PreferredAuthentications=publickey -o PubkeyAuthentication=yes -o TCPKeepAlive=yes -o Compression=yes
        run: bash deploy/scripts/actions/upload-env-files.sh "${{ steps.ssh.outputs.key }}"

      - name: Upload compose file to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/upload-compose.sh "${{ steps.ssh.outputs.key }}"

      - name: Sync Nginx config and reload
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: bash deploy/scripts/actions/sync-nginx.sh "${{ steps.ssh.outputs.key }}"

      - name: (Re)start containers
        if: ${{ inputs.restart_containers == 'true' || inputs.restart_containers == true }}
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/restart-containers.sh "${{ steps.ssh.outputs.key }}"

      - name: Diagnose services (containers and nginx)
        if: failure()
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/diagnose-services.sh "${{ steps.ssh.outputs.key }}"

      - name: Health checks
        if: always()
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          HEALTH_ATTEMPTS: 4
          HEALTH_DELAY_SECONDS: 3
          CURL_ATTEMPTS: 3
          CURL_DELAY_SECONDS: 2
          CURL_MAX_TIME_SECONDS: 3
          CURL_CONNECT_TIMEOUT: 1
        run: bash deploy/scripts/actions/health-checks.sh "${{ steps.ssh.outputs.key }}"

      - name: Dump container logs on failure
        if: failure()
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/dump-logs.sh "${{ steps.ssh.outputs.key }}"
