# Redeploy Workflow (prod + dev restart & env injection)
name: Redeploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: Which profiles to (re)start
        type: choice
        required: true
        default: both
        options:
          - prod
          - dev
          - both
      start_dev:
        description: Ensure dev containers are up in addition to prod
        type: choice
        required: true
        default: "true"
        options:
          - "true"
          - "false"
      refresh_env:
        description: Regenerate and upload .env files to EC2 (requires secrets)
        type: choice
        required: true
        default: "false"
        options:
          - "true"
          - "false"
      restart_containers:
        description: (Re)start containers on EC2 (docker compose pull/up)
        type: choice
        required: true
        default: "true"
        options:
          - "true"
          - "false"

  workflow_call:
    inputs:
      environment:
        description: Which profiles to (re)start
        type: string
        required: true
        default: both
      start_dev:
        description: Ensure dev containers are up in addition to prod
        type: string
        required: true
        default: "true"
      refresh_env:
        description: Regenerate and upload .env files to EC2 (requires secrets)
        type: string
        required: true
        default: "false"
      restart_containers:
        description: (Re)start containers on EC2 (docker compose pull/up)
        type: string
        required: true
        default: "true"

jobs:
  deploy:
    name: SSH redeploy on EC2
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Prevent overlapping prod/dev redeploys from stepping on each other.
    # Use per-environment concurrency so prod and dev can proceed independently.
    # If environment == 'both', fall back to a single global group.
    concurrency:
      group: "redeploy-${{ inputs.environment == 'both' && 'global' || inputs.environment }}"
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare SSH key
        id: ssh
        env:
          SSH_KEY_PEM: ${{ secrets.EC2_SSH_KEY_PEM }}
          SSH_KEY_ALT: ${{ secrets.EC2_SSH_KEY }}
        run: |
          set -euo pipefail
          CONTENT="${SSH_KEY_PEM:-}"
          if [ -z "$CONTENT" ] && [ -n "${SSH_KEY_ALT:-}" ]; then
            CONTENT="$SSH_KEY_ALT"
          fi
          if [ -z "$CONTENT" ]; then
            echo "Missing SSH key secret: provide EC2_SSH_KEY_PEM or EC2_SSH_KEY" >&2
            exit 1
          fi
          umask 177
          printf "%s" "$CONTENT" > key.pem
          echo "key=key.pem" >> "$GITHUB_OUTPUT"

      - name: Validate required inputs
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          REFRESH_ENV: ${{ inputs.refresh_env }}
        run: |
          set -euo pipefail
          : "${ENVIRONMENT}"
          : "${EC2_HOST}"
          : "${REFRESH_ENV}"

      - name: Generate env files (in runner temp)
        id: genenv
        if: ${{ inputs.refresh_env == 'true' || inputs.refresh_env == true }}
        env:
          PROFILES: ${{ inputs.environment }}
        run: |
          set -euo pipefail
          profiles="$PROFILES"
          if [ "$profiles" = "both" ]; then
            profiles="prod,dev"
          fi
          PROFILES="$profiles" bash deploy/scripts/actions/generate-env-files.sh

      - name: Upload env files to EC2
        if: ${{ inputs.refresh_env == 'true' || inputs.refresh_env == true }}
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          OUT_DIR: ${{ steps.genenv.outputs.dir }}
          SSH_OPTS: -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -o ServerAliveInterval=5 -o ServerAliveCountMax=2 -o PreferredAuthentications=publickey -o PubkeyAuthentication=yes -o TCPKeepAlive=yes -o Compression=yes
        run: bash deploy/scripts/actions/upload-env-files.sh "${{ steps.ssh.outputs.key }}"

      - name: Upload compose file to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/upload-compose.sh "${{ steps.ssh.outputs.key }}"

      - name: Sync Nginx config and reload
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: bash deploy/scripts/actions/sync-nginx.sh "${{ steps.ssh.outputs.key }}"

      - name: (Re)start containers
        if: ${{ inputs.restart_containers == 'true' || inputs.restart_containers == true }}
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/restart-containers.sh "${{ steps.ssh.outputs.key }}"

      - name: Diagnose services (containers and nginx)
        if: failure()
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/diagnose-services.sh "${{ steps.ssh.outputs.key }}"

      - name: Health checks
        if: always()
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          START_DEV: ${{ inputs.start_dev }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          # Use extended defaults aligned with container start_period and grace logic
          HEALTH_ATTEMPTS: 12
          HEALTH_DELAY_SECONDS: 5
          CURL_ATTEMPTS: 6
          CURL_DELAY_SECONDS: 5
          CURL_MAX_TIME_SECONDS: 5
          CURL_CONNECT_TIMEOUT: 2
          HEALTH_STARTING_GRACE_SECONDS: 40
        run: bash deploy/scripts/actions/health-checks.sh "${{ steps.ssh.outputs.key }}"

      - name: Dump container logs on failure
        if: failure()
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
        run: bash deploy/scripts/actions/dump-logs.sh "${{ steps.ssh.outputs.key }}"
