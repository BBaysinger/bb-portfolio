# =============================================================================
# CI/CD Pipeline - BB Portfolio Site
# ===============================================================
# ENVIRONMENT FILES (.env.dev, .env.prod)
# ===============================================================
# These files are NOT sourced from the repo during deployment.
# They are dynamically generated on EC2 by the CI/CD workflow,
# with contents exclusively pulled from GitHub Actions secrets and variables.
# Local development uses .env only.
# ===============================================================
# =============================================================================
#
# This workflow provides automated build, test, and deployment for the
# portfolio application with support for multiple environments:
#
# TRIGGERS:
# - Push to 'main' branch: Full CI/CD with production deployment
# - Push to 'dev' branch: CI/CD with development environment rebuild
# - Manual dispatch: Allows manual triggering for any branch
#
# JOBS:
# 1. build-and-test: Validates code quality and builds both frontend/backend
# 2. deploy-prod: Deploys to AWS EC2 production (main branch only)
# 3. rebuild-dev: Rebuilds development environment (dev branch or manual)
#
# DEPLOYMENT TARGETS:
# - Production: Uses pre-built ECR images for fast, reliable deployments
# - Development: Builds directly on EC2 for flexibility and testing
# =============================================================================

name: CI/CD Pipeline

# Workflow triggers
on:
  push:
    branches:
      - main # Production deployments
      - dev # Development environment rebuilds
  workflow_dispatch: # Manual trigger for any branch

jobs:
  # ==========================================================================
  # BUILD AND TEST JOB
  # ==========================================================================
  # Validates code quality, runs tests, and ensures both frontend and backend
  # can be built successfully before any deployment occurs
  # ==========================================================================
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      # Checkout source code
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup Node.js environment
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20 # LTS version for stability

      # =======================================================================
      # BACKEND BUILD AND TEST (Build backend first for frontend SSG)
      # =======================================================================
      - name: Install backend dependencies
        working-directory: ./backend
        run: npm install --legacy-peer-deps # Required for some peer dependency conflicts

      - name: Build backend
        working-directory: ./backend
        env:
          # Use dev profile with a dummy connection string just to satisfy build-time checks
          ENV_PROFILE: dev
          DEV_MONGODB_URI: mongodb://localhost:27017/dummy-db
          # Required by strict env checks in payload.config.ts for dev profile
          DEV_PAYLOAD_SECRET: ${{ secrets.DEV_PAYLOAD_SECRET }}
          # Frontend origin for CORS/CSRF checks during build-time config resolution
          DEV_FRONTEND_URL: ${{ secrets.DEV_FRONTEND_URL }}
          # S3 and AWS configuration required by payload.config.ts during build
          DEV_S3_BUCKET: ${{ secrets.DEV_S3_BUCKET }}
          DEV_AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
          S3_AWS_ACCESS_KEY_ID: ${{ secrets.S3_AWS_ACCESS_KEY_ID }}
          S3_AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_AWS_SECRET_ACCESS_KEY }}
        run: npm run build # Next.js production build (Payload CMS)

      - name: Test backend
        working-directory: ./backend
        env:
          ENV_PROFILE: dev
          DEV_MONGODB_URI: mongodb://localhost:27017/dummy-db
          DEV_PAYLOAD_SECRET: ${{ secrets.DEV_PAYLOAD_SECRET }}
          DEV_FRONTEND_URL: ${{ secrets.DEV_FRONTEND_URL }}
          # S3 and AWS configuration required by payload.config.ts during testing
          DEV_S3_BUCKET: ${{ secrets.DEV_S3_BUCKET }}
          DEV_AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
          S3_AWS_ACCESS_KEY_ID: ${{ secrets.S3_AWS_ACCESS_KEY_ID }}
          S3_AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_AWS_SECRET_ACCESS_KEY }}
        run: npm test || echo "âš ï¸ No backend tests yet" # Graceful failure until tests are implemented

      # =======================================================================
      # FRONTEND BUILD AND TEST (After backend is ready)
      # =======================================================================
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm install --legacy-peer-deps # Required for some peer dependency conflicts

      - name: Build frontend
        working-directory: ./frontend
        env:
          # Ensure profile and backend base are available to prebuild guard and Next.js
          ENV_PROFILE: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
          # Backend URLs for build-time and runtime (consistent naming)
          PROD_BACKEND_INTERNAL_URL: ${{ secrets.PROD_BACKEND_INTERNAL_URL }}
          DEV_BACKEND_INTERNAL_URL: ${{ secrets.DEV_BACKEND_INTERNAL_URL }}
          # Next.js client-side exposed environment variables (NEXT_PUBLIC_*)
          PROD_NEXT_PUBLIC_BACKEND_URL: ${{ secrets.PROD_NEXT_PUBLIC_BACKEND_URL }}
          DEV_NEXT_PUBLIC_BACKEND_URL: ${{ secrets.DEV_NEXT_PUBLIC_BACKEND_URL }}
        run: npm run build:when-ready # Simplified Next.js build

      - name: Test frontend
        working-directory: ./frontend
        run: npm test || echo "âš ï¸ No frontend tests yet" # Graceful failure until tests are implemented

  # ==========================================================================
  # PRODUCTION DEPLOYMENT JOB
  # ==========================================================================
  # Deploys to AWS EC2 production environment using pre-built ECR images
  # Only runs on main branch pushes after successful build and test
  # ==========================================================================
  deploy-prod:
    if: github.ref == 'refs/heads/main' # Production deploys only from main branch
    needs: build-and-test # Wait for successful build and test
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Extended timeout for deployment operations

    steps:
      # Checkout source code for docker-compose.yml and deployment scripts
      - name: Checkout code
        uses: actions/checkout@v4

      # =======================================================================
      # AWS AUTHENTICATION AND ECR LOGIN
      # =======================================================================
      # Configure AWS credentials for ECR access and deployment operations
      # =======================================================================
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.CICD_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CICD_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2 # Oregon region for EC2 and ECR resources

      # Login to Amazon ECR for image registry
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # =======================================================================
      # DOCKER IMAGE BUILD AND PUSH TO ECR
      # =======================================================================
      # Build production-optimized images and push to Amazon ECR registry
      # Uses 'latest' tag for production deployments
      # =======================================================================
      - name: Build and push frontend-prod to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: bb-portfolio-frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building frontend production image..."
          docker build --no-cache --target runner --build-arg ENV_PROFILE=prod --build-arg PROD_BACKEND_INTERNAL_URL="${{ secrets.PROD_BACKEND_INTERNAL_URL }}" --build-arg PROD_NEXT_PUBLIC_BACKEND_URL="${{ secrets.PROD_NEXT_PUBLIC_BACKEND_URL }}" -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./frontend
          echo "ðŸ“¤ Pushing frontend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          # Also tag and push as latest for docker-compose compatibility
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "Frontend ECR push complete: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG and :latest"

      - name: Build and push backend-prod to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: bb-portfolio-backend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building backend production image with Docker BuildKit secrets..."
          # Create temporary files for secrets
          echo "${{ secrets.PROD_MONGODB_URI }}" > /tmp/prod_mongodb_uri
          echo "${{ secrets.DEV_MONGODB_URI }}" > /tmp/dev_mongodb_uri  
          echo "${{ secrets.LOCAL_MONGODB_URI }}" > /tmp/local_mongodb_uri
          echo "${{ secrets.PROD_PAYLOAD_SECRET }}" > /tmp/prod_payload_secret
          echo "${{ secrets.S3_AWS_ACCESS_KEY_ID }}" > /tmp/s3_aws_access_key_id
          echo "${{ secrets.S3_AWS_SECRET_ACCESS_KEY }}" > /tmp/s3_aws_secret_access_key
          # Build with secrets and non-sensitive build args
          DOCKER_BUILDKIT=1 docker build --no-cache --target runtime \
            --build-arg ENV_PROFILE=prod \
            --build-arg PROD_FRONTEND_URL="${{ secrets.PROD_FRONTEND_URL }}" \
            --build-arg PROD_S3_BUCKET="${{ secrets.PROD_S3_BUCKET }}" \
            --build-arg PROD_AWS_REGION="${{ secrets.PROD_AWS_REGION }}" \
            --build-arg DEV_AWS_REGION="${{ secrets.DEV_AWS_REGION }}" \
            --secret id=prod_mongodb_uri,src=/tmp/prod_mongodb_uri \
            --secret id=dev_mongodb_uri,src=/tmp/dev_mongodb_uri \
            --secret id=local_mongodb_uri,src=/tmp/local_mongodb_uri \
            --secret id=prod_payload_secret,src=/tmp/prod_payload_secret \
            --secret id=s3_aws_access_key_id,src=/tmp/s3_aws_access_key_id \
            --secret id=s3_aws_secret_access_key,src=/tmp/s3_aws_secret_access_key \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          # Clean up temporary files
          rm -f /tmp/prod_mongodb_uri /tmp/dev_mongodb_uri /tmp/local_mongodb_uri /tmp/prod_payload_secret /tmp/s3_aws_access_key_id /tmp/s3_aws_secret_access_key
          echo "ðŸ“¤ Pushing backend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          # Also tag and push as latest for docker-compose compatibility  
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "Backend ECR push complete: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG and :latest"

      # =======================================================================
      # EC2 PRODUCTION DEPLOYMENT
      # =======================================================================
      # Deploy to production EC2 instance using SSH automation
      # Handles Docker/AWS CLI installation and zero-downtime deployment
      # =======================================================================
      - name: Deploy prod on EC2
        uses: appleboy/ssh-action@v1.0.3
        timeout-minutes: 15 # Extended timeout for Docker installation and health checks
        with:
          host: ${{ secrets.EC2_HOST }} # EC2 public IP address
          username: ec2-user # Default Amazon Linux user
          key: ${{ secrets.EC2_SSH_KEY }} # SSH private key for authentication
          command_timeout: 12m # Extended SSH command timeout
          script: |
            echo "ðŸš€ Starting production deployment at $(date)"
            echo "ðŸ“ Deploying to: $(hostname)"

            # ===============================================================
            # INFRASTRUCTURE SETUP
            # ===============================================================
            # Install required tools if not present on EC2 instance
            # ===============================================================

            # Install Docker if not present
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo yum update -y
              sudo yum install -y docker
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -a -G docker ec2-user
              echo "Docker installation complete"
            else
              echo "Docker already installed"
            fi

            # Install AWS CLI for ECR authentication
            if ! command -v aws &> /dev/null; then
              echo "Installing AWS CLI..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
              echo "AWS CLI installation complete"
            else
              echo "AWS CLI already installed"
            fi

            # Install Docker Compose plugin if not present
            if ! docker compose version &> /dev/null; then
              echo "Installing Docker Compose..."
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
              echo "Docker Compose installation complete"
            else
              echo "Docker Compose already installed"
            fi

            # =============================================================
            # DOCKER SERVICE PREPARATION
            # =============================================================
            # Ensure Docker daemon is running and ready
            # =============================================================
            echo "Preparing Docker services..."
            sudo systemctl daemon-reload
            sudo systemctl start docker
            sudo systemctl enable docker

            # Wait for docker to be ready
            echo "Waiting for Docker to be ready..."
            sleep 5

            # Verify docker is working
            echo "Verifying Docker installation..."
            sudo docker --version
            echo "Docker verification complete"            # ===============================================================
            # AWS AUTHENTICATION AND ECR SETUP
            # ===============================================================
            # Configure AWS credentials for ECR access from EC2
            # ===============================================================
            echo "ðŸ” Configuring AWS credentials..."
            aws configure set aws_access_key_id ${{ secrets.CICD_AWS_ACCESS_KEY_ID }}
            aws configure set aws_secret_access_key ${{ secrets.CICD_AWS_SECRET_ACCESS_KEY }}
            aws configure set default.region us-west-2

            # Login to ECR for pulling production images
            echo "ðŸ” Authenticating with Amazon ECR..."
            aws ecr get-login-password --region us-west-2 | sudo docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}

            # ===============================================================
            # REPOSITORY SETUP
            # ===============================================================
            # Clone or update project repository for docker-compose.yml
            # ===============================================================
            if ! command -v git &> /dev/null; then
              echo "Installing Git..."
              sudo yum install -y git
            fi

            echo "ðŸ“¥ Setting up project repository..."
            cd $HOME
            if [ ! -d "portfolio" ]; then
              echo "ðŸ“¥ Cloning repository..."
              git clone https://github.com/BBaysinger/bb-portfolio.git portfolio
            else
              echo "ðŸ”„ Updating existing repository..."
              cd portfolio
              # Check if we're in a git repository
              if [ -d ".git" ]; then
                git fetch origin
                git checkout main
                git reset --hard origin/main
              else
                echo "âš ï¸ Not a git repository, removing and re-cloning..."
                cd ..
                rm -rf portfolio
                git clone https://github.com/BBaysinger/bb-portfolio.git portfolio
              fi
              cd $HOME
            fi

            # ===============================================================
            # ENVIRONMENT CONFIGURATION
            # ===============================================================
            # Create production environment files from GitHub secrets
            # ===============================================================
            cd ~/portfolio
            echo "âš™ï¸ Creating production environment files..."
            echo "ðŸ“ Current directory: $(pwd)"
            echo "ðŸ“‚ Directory contents:"
            ls -la

            # Ensure directories exist
            mkdir -p backend frontend

            # Backend production environment
            cat > backend/.env.prod << EOF
            PORT=3000
            # Prefix-first envs: use PROD_MONGODB_URI exclusively
            PROD_MONGODB_URI=${{ secrets.PROD_MONGODB_URI }}
            PROD_PAYLOAD_SECRET=${{ secrets.PROD_PAYLOAD_SECRET }}
            # Frontend origin for CORS/CSRF
            PROD_FRONTEND_URL=${{ secrets.PROD_FRONTEND_URL }}
            # AWS S3 Configuration for Payload uploads
            S3_AWS_ACCESS_KEY_ID=${{ secrets.S3_AWS_ACCESS_KEY_ID }}
            S3_AWS_SECRET_ACCESS_KEY=${{ secrets.S3_AWS_SECRET_ACCESS_KEY }}
            PROD_AWS_REGION=${{ secrets.PROD_AWS_REGION }}
            PROD_S3_BUCKET=${{ secrets.PROD_S3_BUCKET }}
            NODE_ENV=production
            ENV_PROFILE=prod
            EOF

            # Frontend production environment
            cat > frontend/.env.prod << EOF
            NODE_ENV=production
            ENV_PROFILE=prod
            # Prefixed environment variables (ENV_PROFILE=prod means PROD_ prefix)
            PROD_BACKEND_INTERNAL_URL=${{ secrets.PROD_BACKEND_INTERNAL_URL }}
            PROD_NEXT_PUBLIC_BACKEND_URL=${{ secrets.PROD_NEXT_PUBLIC_BACKEND_URL }}
            # Next.js requires NEXT_PUBLIC_ variables for browser exposure
            NEXT_PUBLIC_BACKEND_URL=${{ secrets.PROD_NEXT_PUBLIC_BACKEND_URL }}
            EOF

            # Debug: Show environment file contents
            echo "ðŸ“‹ Frontend .env.prod contents:"
            cat frontend/.env.prod

            # ===============================================================
            # DISK SPACE CLEANUP
            # ===============================================================
            # Clean up disk space before deployment to prevent "no space left" errors
            # ===============================================================
            echo "ðŸ§¹ Checking and cleaning up disk space..."
            df -h
            
            echo "ðŸ³ Cleaning up Docker resources to free disk space..."
            # Remove unused Docker images
            sudo docker image prune -a -f || echo "âš ï¸ Docker image cleanup failed"
            # Remove unused containers
            sudo docker container prune -f || echo "âš ï¸ Docker container cleanup failed"
            # Remove unused volumes
            sudo docker volume prune -f || echo "âš ï¸ Docker volume cleanup failed"
            # Remove build cache
            sudo docker builder prune -a -f || echo "âš ï¸ Docker builder cache cleanup failed"
            
            echo "ðŸ—‚ï¸ Cleaning up system files..."
            # Clean up logs if they're taking space
            sudo journalctl --vacuum-size=100M || echo "âš ï¸ Journal cleanup failed"
            # Clean up package cache
            sudo yum clean all || echo "âš ï¸ Package cache cleanup failed"
            
            echo "ðŸ“Š Disk usage after cleanup:"
            df -h

            # ===============================================================
            # CONTAINER DEPLOYMENT
            # ===============================================================
            # Pull latest images and deploy with zero-downtime strategy
            # ===============================================================
            echo "â¬‡ï¸ Getting AWS account ID for ECR URIs..."
            export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
            echo "Using AWS Account ID: $AWS_ACCOUNT_ID"

            echo "â¬‡ï¸ Pulling latest production images from ECR..."
            sudo -E docker compose pull || {
              echo "âš ï¸ Failed to pull images. Continuing with existing images..."
            }

            # Deployment status check
            echo "Pre-deployment status check..."
            echo "System resources:"
            df -h | head -5  # Disk space
            free -h          # Memory usage
            echo "ðŸ“ Current user: $(whoami)"
            echo "ðŸ“ Working directory: $(pwd)"

            echo "ðŸš€ Starting production deployment..."
            # Force recreate containers to use new images
            # Export environment variables for docker-compose
            export AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID
            export PROD_BACKEND_INTERNAL_URL="${{ secrets.PROD_BACKEND_INTERNAL_URL }}"
            export PROD_NEXT_PUBLIC_BACKEND_URL="${{ secrets.PROD_NEXT_PUBLIC_BACKEND_URL }}"
            export COMPOSE_PROFILES=prod
            
            # Backend environment variables - required for Payload CMS
            export PROD_MONGODB_URI="${{ secrets.PROD_MONGODB_URI }}"
            export PROD_PAYLOAD_SECRET="${{ secrets.PROD_PAYLOAD_SECRET }}"
            export PROD_FRONTEND_URL="${{ secrets.PROD_FRONTEND_URL }}"
            export S3_AWS_ACCESS_KEY_ID="${{ secrets.S3_AWS_ACCESS_KEY_ID }}"
            export S3_AWS_SECRET_ACCESS_KEY="${{ secrets.S3_AWS_SECRET_ACCESS_KEY }}"
            export PROD_AWS_REGION="${{ secrets.PROD_AWS_REGION }}"
            export PROD_S3_BUCKET="${{ secrets.PROD_S3_BUCKET }}"

            echo "ðŸ³ Environment variables for docker-compose:"
            echo "AWS_ACCOUNT_ID: ${AWS_ACCOUNT_ID}"
            echo "PROD_BACKEND_INTERNAL_URL: ***"
            echo "PROD_NEXT_PUBLIC_BACKEND_URL: ***"
            echo "COMPOSE_PROFILES: ${COMPOSE_PROFILES}"

            # Also source frontend env file to ensure variables are available
            echo "ðŸ“‹ Sourcing frontend environment variables..."
            set -a  # Automatically export all variables
            source frontend/.env.prod
            set +a  # Stop auto-exporting

            # Show what variables are now available
            echo "ðŸ” Environment variables available to docker-compose:"
            env | grep -E "(AWS_ACCOUNT_ID|PROD_BACKEND|NEXT_PUBLIC|COMPOSE_PROFILES)" | sort

            sudo -E docker compose up -d --force-recreate --pull always

            # ===============================================================
            # HEALTH CHECKS AND VALIDATION
            # ===============================================================
            # Wait for containers to start and validate deployment
            # ===============================================================
            echo "Waiting for containers to initialize..."
            sleep 20

            echo "Checking container logs..."
            echo "=== Backend Container Logs ==="
            sudo docker logs portfolio-backend-prod --tail 50 || echo "âš ï¸ Backend container not found"

            echo "=== Frontend Container Logs ==="
            sudo docker logs portfolio-frontend-prod --tail 50 || echo "âš ï¸ Frontend container not found"

            echo "Final deployment status:"
            sudo docker ps
            sudo -E docker compose ps

            # Debug: Check environment variables in running container
            echo "ðŸ” Checking frontend container environment:"
            echo "=== All environment variables in frontend container ==="
            sudo docker exec portfolio-frontend-prod env | sort || echo "âš ï¸ Could not read container environment"

            echo "=== Specific backend-related variables ==="
            sudo docker exec portfolio-frontend-prod env | grep -E "(BACKEND|NEXT_PUBLIC|ENV_PROFILE|NODE_ENV)" || echo "âš ï¸ No backend environment variables found"

            echo "=== Contents of .env.prod file in container ==="
            sudo docker exec portfolio-frontend-prod cat /app/.env.prod 2>/dev/null || echo "âš ï¸ No .env.prod file found in container"

            echo "Production deployment complete at $(date)!"

  # ==========================================================================
  # DEVELOPMENT REBUILD JOB - SIMPLE EC2 BUILD
  # ==========================================================================
  # ==========================================================================
  # DEVELOPMENT REBUILD JOB
  # ==========================================================================
  # Builds development images and pushes to Docker Hub, then deploys to EC2
  # Triggered by pushes to 'dev' branch or manual workflow dispatch
  # Uses Docker Hub for cost optimization and dual-registry experience
  # ==========================================================================
  rebuild-dev:
    if: github.ref == 'refs/heads/dev' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    # Run independently - don't wait for build-and-test to complete
    steps:
      # Checkout source code for building Docker images
      - name: Checkout code
        uses: actions/checkout@v4

      # =======================================================================
      # DOCKER HUB AUTHENTICATION
      # =======================================================================
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      # =======================================================================
      # BUILD AND PUSH DEV IMAGES TO DOCKER HUB
      # =======================================================================
      - name: Build and push dev images to Docker Hub
        run: |
          echo "ðŸ—ï¸ Building development images..."

          # Build backend dev image
          docker build \
            --build-arg ENV_PROFILE=dev \
            -t bhbaysinger/portfolio-backend:dev ./backend

          # Build frontend dev image  
          docker build \
            --build-arg ENV_PROFILE=dev \
            --build-arg DEV_BACKEND_INTERNAL_URL=${{ secrets.DEV_BACKEND_INTERNAL_URL }} \
            --build-arg DEV_NEXT_PUBLIC_BACKEND_URL=${{ secrets.DEV_NEXT_PUBLIC_BACKEND_URL }} \
            -t bhbaysinger/portfolio-frontend:dev ./frontend

          echo "ðŸ“¤ Pushing images to Docker Hub..."
          docker push bhbaysinger/portfolio-backend:dev
          docker push bhbaysinger/portfolio-frontend:dev

          echo "âœ… Docker Hub push complete!"

      # =======================================================================
      # EC2 DEPLOYMENT
      # =======================================================================
      - name: Deploy dev to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }} # EC2 public IP address
          username: ec2-user # Default Amazon Linux user
          key: ${{ secrets.EC2_SSH_KEY }} # SSH private key for authentication
          script: |
            # =============================================================
            # REPOSITORY SETUP
            # =============================================================
            # Clone or update the project repository
            # =============================================================
            cd $HOME
            if [ ! -d "portfolio" ]; then
              git clone https://github.com/BBaysinger/bb-portfolio.git portfolio
            else
              cd portfolio
              git fetch origin
              git checkout dev
              git reset --hard origin/dev
              cd ..
            fi

            # =============================================================
            # DOCKER INSTALLATION
            # =============================================================
            # Install Docker and Docker Compose if not present
            # =============================================================
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo yum update -y
              sudo yum install -y docker
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -a -G docker ec2-user
              echo "Docker installation complete"
            fi

            # Modern Docker includes compose as a plugin, no need to install separately
            echo "Docker Compose is included with Docker installation"

            # =============================================================
            # DOCKER SERVICE PREPARATION
            # =============================================================
            # Ensure Docker daemon is running and ready
            # =============================================================
            echo "Preparing Docker services..."
            sudo systemctl daemon-reload
            sudo systemctl start docker
            sudo systemctl enable docker

            # Wait for docker to be ready
            echo "Waiting for Docker to be ready..."
            sleep 5

            # Verify docker is working
            echo "Verifying Docker installation..."
            sudo docker --version
            echo "Docker verification complete"

            # =============================================================
            # ENVIRONMENT CONFIGURATION
            # =============================================================
            # Create development environment files from GitHub secrets
            # =============================================================
            echo "Configuring environment files..."
            cd $HOME/portfolio

            # Create backend .env.dev
            echo "Creating backend .env.dev..."
            cat > backend/.env.dev << EOF
            PORT=3000
            # Prefix-first envs: use DEV_MONGODB_URI exclusively
            DEV_MONGODB_URI=${{ secrets.DEV_MONGODB_URI }}
            DEV_PAYLOAD_SECRET=${{ secrets.DEV_PAYLOAD_SECRET }}
            # Frontend origin for CORS/CSRF
            DEV_FRONTEND_URL=${{ secrets.DEV_FRONTEND_URL }}
            # AWS S3 Configuration for Payload uploads
            S3_AWS_ACCESS_KEY_ID=${{ secrets.S3_AWS_ACCESS_KEY_ID }}
            S3_AWS_SECRET_ACCESS_KEY=${{ secrets.S3_AWS_SECRET_ACCESS_KEY }}
            DEV_AWS_REGION=${{ secrets.DEV_AWS_REGION }}
            DEV_S3_BUCKET=${{ secrets.DEV_S3_BUCKET }}
            NODE_ENV=development
            ENV_PROFILE=dev
            EOF

            # Create frontend .env.dev
            echo "Creating frontend .env.dev..."
            # Frontend development environment  
            cat > frontend/.env.dev << EOF
            NODE_ENV=development
            ENV_PROFILE=dev
            # Prefixed environment variables (ENV_PROFILE=dev means DEV_ prefix)
            DEV_BACKEND_INTERNAL_URL=${{ secrets.DEV_BACKEND_INTERNAL_URL }}
            DEV_NEXT_PUBLIC_BACKEND_URL=${{ secrets.DEV_NEXT_PUBLIC_BACKEND_URL }}
            # Next.js requires NEXT_PUBLIC_ variables for browser exposure
            NEXT_PUBLIC_BACKEND_URL=${{ secrets.DEV_NEXT_PUBLIC_BACKEND_URL }}
            EOF
            echo "Environment configuration complete"

            # =============================================================
            # CONTAINER DEPLOYMENT
            # =============================================================
            # Deploy development environment with docker-compose
            # Uses dev profile and builds images directly on EC2
            # =============================================================
            echo "Starting container deployment..."
            echo "Current directory: $(pwd)"
            echo "Docker Compose version: $(sudo docker compose version)"

            echo "Building and starting development containers..."
            echo "âš ï¸  Note: Docker builds may take a few minutes on t3.small instances"

            # Pull latest images from Docker Hub and start containers
            echo "Pulling latest development images from Docker Hub..."
            sudo docker pull bhbaysinger/portfolio-backend:dev
            sudo docker pull bhbaysinger/portfolio-frontend:dev

            echo "Starting development containers with latest images..."
            sudo COMPOSE_PROFILES=dev docker compose up -d

            echo "Development environment rebuild complete!"
            echo "Backend available on port 4000"
            echo "Frontend available on port 4001"

            echo "Container status:"
            sudo docker ps
