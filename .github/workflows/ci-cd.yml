# =============================================================================
# CI/CD Pipeline - BB-Portfolio Site
# ===============================================================
# ENVIRONMENT FILES (.env.dev, .env.prod)
# ===============================================================
# These files are NOT sourced from the repo during deployment.
# They are dynamically generated on EC2 by the CI/CD workflow,
# with contents exclusively pulled from GitHub Actions secrets and variables.
# Local development uses .env only.
# ===============================================================
# =============================================================================
#
# This workflow provides automated build, test, and deployment for the
# portfolio application with support for multiple environments:
#
# TRIGGERS:
# - Push to 'main' branch: Full CI/CD with production deployment
# - Push to 'dev' branch: CI/CD with development environment rebuild
# - Manual dispatch: Allows manual triggering for any branch
#
# JOBS:
# 1. build-and-test: Validates code quality and builds both frontend/backend
# 2. deploy-prod: Deploys to AWS EC2 production (main branch only)
# 3. rebuild-dev: Rebuilds development environment (dev branch or manual)
#
# DEPLOYMENT TARGETS:
# - Production: Uses pre-built ECR images for fast, reliable deployments
# - Development: Builds directly on EC2 for flexibility and testing
# =============================================================================

name: CI/CD Pipeline

# Workflow triggers
on:
  push:
    branches:
      - main # Production deployments
      - dev # Development environment rebuilds
  workflow_dispatch: # Manual trigger for any branch

jobs:
  # ==========================================================================
  # BUILD AND TEST JOB
  # ==========================================================================
  # Validates code quality, runs tests, and ensures both frontend and backend
  # can be built successfully before any deployment occurs
  # ==========================================================================
  build-and-test:
    runs-on: ubuntu-latest
    environment: dev
    steps:
      # Checkout source code
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup Node.js environment
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20 # LTS version for stability
          # Do not use pnpm cache here to avoid requiring pnpm before it's installed

      # Install pnpm explicitly to ensure availability on runner
      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9
          run_install: false

      # Fallback: ensure pnpm is on PATH even if action was skipped/restricted
      - name: Ensure pnpm available
        run: |
          if ! command -v pnpm >/dev/null 2>&1; then
            echo "pnpm not found on PATH; installing via npm..."
            npm i -g pnpm@9
            pnpm -v
          else
            echo "pnpm already available: $(pnpm -v)"
          fi

      - name: pnpm version
        run: pnpm -v

      # Sanitize required env list: split frontend/backend requirements
      - name: Sanitize required env lists (dev build)
        id: sanitize-dev-req
        env:
          RAW_FRONTEND: ${{ secrets.REQUIRED_ENVIRONMENT_VARIABLES_FRONTEND }}
          RAW_BACKEND: ${{ secrets.REQUIRED_ENVIRONMENT_VARIABLES_BACKEND }}
        run: bash deploy/scripts/actions/sanitize-required-env.sh dev "$RAW_FRONTEND" "$RAW_BACKEND"

      # =======================================================================
      # BACKEND BUILD AND TEST (Build backend first for frontend SSG)
      # =======================================================================
      - name: Install backend dependencies (pnpm)
        working-directory: ./backend
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1" # Avoid heavy download during install
        run: pnpm install --no-frozen-lockfile --prefer-offline

      - name: Build backend
        working-directory: ./backend
        env:
          # Use dev profile with a dummy connection string just to satisfy build-time checks
          ENV_PROFILE: dev
          # Env-guard definition list (sanitized for backend build)
          REQUIRED_ENVIRONMENT_VARIABLES_BACKEND: "${{ steps.sanitize-dev-req.outputs.dev_req_backend }}"
          # Explicit public origin for Payload admin/API
          PAYLOAD_PUBLIC_SERVER_URL: ${{ secrets.FRONTEND_URL }}
          # PUBLIC_SERVER_URL is part of the backend required env set
          PUBLIC_SERVER_URL: ${{ secrets.PUBLIC_SERVER_URL || secrets.FRONTEND_URL }}
          # Backend URL group (ANY-of) to satisfy unified list if it includes FE groups
          BACKEND_INTERNAL_URL: ${{ secrets.BACKEND_INTERNAL_URL }}
          MONGODB_URI: mongodb://localhost:27017/dummy-db
          # Required by strict env checks in payload.config.ts for dev profile
          PAYLOAD_SECRET: ${{ secrets.PAYLOAD_SECRET }}
          # Frontend origin for CORS/CSRF checks during build-time config resolution
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          # S3 and AWS configuration required by payload.config.ts during build
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          # S3 projects buckets for API routes
          PUBLIC_PROJECTS_BUCKET: ${{ secrets.PUBLIC_PROJECTS_BUCKET }}
          NDA_PROJECTS_BUCKET: ${{ secrets.NDA_PROJECTS_BUCKET }}
          # Unified AWS credentials for all services (S3, SES, deployment)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          SES_FROM_EMAIL: ${{ secrets.SES_FROM_EMAIL }}
          SES_TO_EMAIL: ${{ secrets.SES_TO_EMAIL }}
        run: pnpm run build # Next.js production build (Payload CMS)

      # Install Playwright browsers only when running tests
      - name: Install Playwright browsers
        working-directory: ./backend
        run: pnpm exec playwright install --with-deps || true

      - name: Test backend
        working-directory: ./backend
        env:
          ENV_PROFILE: dev
          PAYLOAD_PUBLIC_SERVER_URL: ${{ secrets.FRONTEND_URL }}
          MONGODB_URI: mongodb://localhost:27017/dummy-db
          PAYLOAD_SECRET: ${{ secrets.PAYLOAD_SECRET }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          PUBLIC_SERVER_URL: ${{ secrets.PUBLIC_SERVER_URL || secrets.FRONTEND_URL }}
          # S3 and AWS configuration required by payload.config.ts during testing
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          # S3 projects buckets for API routes
          PUBLIC_PROJECTS_BUCKET: ${{ secrets.PUBLIC_PROJECTS_BUCKET }}
          NDA_PROJECTS_BUCKET: ${{ secrets.NDA_PROJECTS_BUCKET }}
          # Unified AWS credentials for all services (S3, SES, deployment)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          SES_FROM_EMAIL: ${{ secrets.SES_FROM_EMAIL }}
          SES_TO_EMAIL: ${{ secrets.SES_TO_EMAIL }}
          # Backend URL group (ANY-of) and security metadata to satisfy env-guard when invoked
          BACKEND_INTERNAL_URL: ${{ secrets.BACKEND_INTERNAL_URL }}
          # Ensure tests use a definition list (backend-safe)
          REQUIRED_ENVIRONMENT_VARIABLES_BACKEND: "${{ steps.sanitize-dev-req.outputs.dev_req_backend }}"
        run: pnpm test || echo "⚠️ No backend tests yet" # Graceful failure until tests are implemented

      # =======================================================================
      # FRONTEND BUILD AND TEST (After backend is ready)
      # =======================================================================
      - name: Install frontend dependencies (pnpm)
        working-directory: ./frontend
        run: pnpm install --no-frozen-lockfile --prefer-offline

      - name: Build frontend
        working-directory: ./frontend
        env:
          ENV_PROFILE: dev
          # Env-guard definition list (sanitized for frontend build)
          REQUIRED_ENVIRONMENT_VARIABLES_FRONTEND: "${{ steps.sanitize-dev-req.outputs.dev_req_frontend }}"
          BACKEND_INTERNAL_URL: ${{ secrets.BACKEND_INTERNAL_URL }}
          PUBLIC_PROJECTS_BUCKET: ${{ secrets.PUBLIC_PROJECTS_BUCKET }}
          NDA_PROJECTS_BUCKET: ${{ secrets.NDA_PROJECTS_BUCKET }}
        run: pnpm run build

  # Build and push production images to ECR (main branch)
  build-push-prod-images:
    if: github.ref == 'refs/heads/main'
    needs: build-and-test
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Sanitize required env lists (prod images)
        id: sanitize-prod-req
        env:
          RAW_FRONTEND: ${{ secrets.REQUIRED_ENVIRONMENT_VARIABLES_FRONTEND }}
          RAW_BACKEND: ${{ secrets.REQUIRED_ENVIRONMENT_VARIABLES_BACKEND }}
        run: bash deploy/scripts/actions/sanitize-required-env.sh prod "$RAW_FRONTEND" "$RAW_BACKEND"
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build and push bb-portfolio-frontend-prod to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: bb-portfolio-frontend-prod
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "${{ steps.sanitize-prod-req.outputs.prod_req_frontend }}" > /tmp/required_environment_variables_frontend
          echo "${{ secrets.BACKEND_INTERNAL_URL }}" > /tmp/backend_internal_url
          echo "${{ secrets.PUBLIC_PROJECTS_BUCKET }}" > /tmp/public_projects_bucket
          echo "${{ secrets.NDA_PROJECTS_BUCKET }}" > /tmp/nda_projects_bucket
          echo "${{ secrets.NEXT_PUBLIC_RUM_APP_MONITOR_ID }}" > /tmp/next_public_rum_app_monitor_id
          echo "${{ secrets.NEXT_PUBLIC_RUM_IDENTITY_POOL_ID }}" > /tmp/next_public_rum_identity_pool_id
          echo "${{ secrets.NEXT_PUBLIC_RUM_GUEST_ROLE_ARN }}" > /tmp/next_public_rum_guest_role_arn
          echo "${{ secrets.NEXT_PUBLIC_RUM_REGION }}" > /tmp/next_public_rum_region
          echo "${{ secrets.NEXT_PUBLIC_RUM_DEBUG }}" > /tmp/next_public_rum_debug
          docker build --no-cache --target runner \
            --build-arg NODE_IMAGE=public.ecr.aws/docker/library/node:22-slim \
            --build-arg ENV_PROFILE=prod \
            --build-arg NODE_ENV=production \
            --build-arg GITHUB_SHA=${{ github.sha }} \
            --secret id=required_environment_variables_frontend,src=/tmp/required_environment_variables_frontend \
            --secret id=backend_internal_url,src=/tmp/backend_internal_url \
            --secret id=public_projects_bucket,src=/tmp/public_projects_bucket \
            --secret id=nda_projects_bucket,src=/tmp/nda_projects_bucket \
            --secret id=next_public_rum_app_monitor_id,src=/tmp/next_public_rum_app_monitor_id \
            --secret id=next_public_rum_identity_pool_id,src=/tmp/next_public_rum_identity_pool_id \
            --secret id=next_public_rum_guest_role_arn,src=/tmp/next_public_rum_guest_role_arn \
            --secret id=next_public_rum_region,src=/tmp/next_public_rum_region \
            --secret id=next_public_rum_debug,src=/tmp/next_public_rum_debug \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./frontend
          rm -f /tmp/required_environment_variables_frontend /tmp/backend_internal_url /tmp/public_projects_bucket /tmp/nda_projects_bucket /tmp/next_public_rum_app_monitor_id /tmp/next_public_rum_identity_pool_id /tmp/next_public_rum_guest_role_arn /tmp/next_public_rum_region /tmp/next_public_rum_debug
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
      - name: Build and push bb-portfolio-backend-prod to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: bb-portfolio-backend-prod
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "${{ secrets.MONGODB_URI }}" > /tmp/mongodb_uri
          echo "${{ secrets.PAYLOAD_SECRET }}" > /tmp/payload_secret
          echo "${{ secrets.AWS_ACCESS_KEY_ID }}" > /tmp/aws_access_key_id
          echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" > /tmp/aws_secret_access_key
          echo "${{ secrets.SES_FROM_EMAIL }}" > /tmp/ses_from_email
          echo "${{ secrets.SES_TO_EMAIL }}" > /tmp/ses_to_email
          echo "${{ secrets.SMTP_FROM_EMAIL }}" > /tmp/smtp_from_email
          echo "${{ secrets.FRONTEND_URL }}" > /tmp/frontend_url
          echo "${{ secrets.PUBLIC_SERVER_URL || secrets.FRONTEND_URL }}" > /tmp/public_server_url
          echo "${{ secrets.S3_BUCKET }}" > /tmp/s3_bucket
          echo "${{ secrets.PUBLIC_PROJECTS_BUCKET }}" > /tmp/public_projects_bucket
          echo "${{ secrets.NDA_PROJECTS_BUCKET }}" > /tmp/nda_projects_bucket
          echo "${{ secrets.AWS_REGION }}" > /tmp/aws_region
          echo "${{ secrets.BACKEND_INTERNAL_URL }}" > /tmp/backend_internal_url
          DOCKER_BUILDKIT=1 docker build --no-cache --target runtime \
            --build-arg NODE_IMAGE=public.ecr.aws/docker/library/node:22-slim \
            --build-arg ENV_PROFILE=prod \
            --build-arg NODE_ENV=production \
            --build-arg REQUIRED_ENVIRONMENT_VARIABLES_BACKEND="${{ steps.sanitize-prod-req.outputs.prod_req_backend }}" \
            --secret id=mongodb_uri,src=/tmp/mongodb_uri \
            --secret id=payload_secret,src=/tmp/payload_secret \
            --secret id=aws_access_key_id,src=/tmp/aws_access_key_id \
            --secret id=aws_secret_access_key,src=/tmp/aws_secret_access_key \
            --secret id=ses_from_email,src=/tmp/ses_from_email \
            --secret id=ses_to_email,src=/tmp/ses_to_email \
            --secret id=smtp_from_email,src=/tmp/smtp_from_email \
            --secret id=public_server_url,src=/tmp/public_server_url \
            --secret id=frontend_url,src=/tmp/frontend_url \
            --secret id=s3_bucket,src=/tmp/s3_bucket \
            --secret id=public_projects_bucket,src=/tmp/public_projects_bucket \
            --secret id=nda_projects_bucket,src=/tmp/nda_projects_bucket \
            --secret id=aws_region,src=/tmp/aws_region \
            --secret id=backend_internal_url,src=/tmp/backend_internal_url \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          rm -f /tmp/mongodb_uri /tmp/payload_secret /tmp/aws_access_key_id /tmp/aws_secret_access_key /tmp/ses_from_email /tmp/ses_to_email /tmp/smtp_from_email /tmp/public_server_url /tmp/frontend_url /tmp/s3_bucket /tmp/public_projects_bucket /tmp/nda_projects_bucket /tmp/aws_region /tmp/backend_internal_url
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  # Deploy to EC2 via reusable workflow (prod)
  deploy-prod:
    if: github.ref == 'refs/heads/main'
    needs: [build-and-test, build-push-prod-images]
    uses: ./.github/workflows/redeploy.yml
    secrets: inherit
    with:
      environment: prod
      start_dev: ${{ 'false' }}
      refresh_env: ${{ 'true' }}
      restart_containers: ${{ 'true' }}

  # Build and push dev images to Docker Hub (dev branch or manual)
  build-push-dev-images:
    # Only run for dev branch pushes or manual runs targeted at the dev branch.
    # Prevents accidental triggering from manual runs on main, which could
    # overlap with prod deploy and get canceled by concurrency.
    if: github.ref == 'refs/heads/dev' || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/dev')
    needs: build-and-test
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Sanitize required env lists (dev images)
        id: sanitize-dev-req
        env:
          RAW_FRONTEND: ${{ secrets.REQUIRED_ENVIRONMENT_VARIABLES_FRONTEND }}
          RAW_BACKEND: ${{ secrets.REQUIRED_ENVIRONMENT_VARIABLES_BACKEND }}
        run: bash deploy/scripts/actions/sanitize-required-env.sh dev "$RAW_FRONTEND" "$RAW_BACKEND"
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      - name: Build and push dev images to Docker Hub
        env:
          SANITIZED_FE_REQ: ${{ steps.sanitize-dev-req.outputs.dev_req_frontend }}
          SANITIZED_BE_REQ: ${{ steps.sanitize-dev-req.outputs.dev_req_backend }}
        run: |
          echo "${{ secrets.MONGODB_URI }}" > /tmp/mongodb_uri
          echo "${{ secrets.PAYLOAD_SECRET }}" > /tmp/payload_secret
          echo "${{ secrets.AWS_ACCESS_KEY_ID }}" > /tmp/aws_access_key_id
          echo "${{ secrets.AWS_SECRET_ACCESS_KEY }}" > /tmp/aws_secret_access_key
          echo "${{ secrets.SES_FROM_EMAIL }}" > /tmp/ses_from_email
          echo "${{ secrets.SES_TO_EMAIL }}" > /tmp/ses_to_email
          echo "${{ secrets.SMTP_FROM_EMAIL }}" > /tmp/smtp_from_email
          echo "${{ secrets.FRONTEND_URL }}" > /tmp/frontend_url
          echo "${{ secrets.PUBLIC_SERVER_URL || secrets.FRONTEND_URL }}" > /tmp/public_server_url
          echo "${{ secrets.S3_BUCKET }}" > /tmp/s3_bucket
          echo "${{ secrets.PUBLIC_PROJECTS_BUCKET }}" > /tmp/public_projects_bucket
          echo "${{ secrets.NDA_PROJECTS_BUCKET }}" > /tmp/nda_projects_bucket
          echo "${{ secrets.AWS_REGION }}" > /tmp/aws_region
          echo "${{ secrets.BACKEND_INTERNAL_URL }}" > /tmp/backend_internal_url
          DOCKER_BUILDKIT=1 docker build \
            --build-arg ENV_PROFILE=dev \
            --build-arg REQUIRED_ENVIRONMENT_VARIABLES_BACKEND="${SANITIZED_BE_REQ}" \
            --secret id=mongodb_uri,src=/tmp/mongodb_uri \
            --secret id=payload_secret,src=/tmp/payload_secret \
            --secret id=aws_access_key_id,src=/tmp/aws_access_key_id \
            --secret id=aws_secret_access_key,src=/tmp/aws_secret_access_key \
            --secret id=ses_from_email,src=/tmp/ses_from_email \
            --secret id=ses_to_email,src=/tmp/ses_to_email \
            --secret id=smtp_from_email,src=/tmp/smtp_from_email \
            --secret id=public_server_url,src=/tmp/public_server_url \
            --secret id=frontend_url,src=/tmp/frontend_url \
            --secret id=s3_bucket,src=/tmp/s3_bucket \
            --secret id=public_projects_bucket,src=/tmp/public_projects_bucket \
            --secret id=nda_projects_bucket,src=/tmp/nda_projects_bucket \
            --secret id=aws_region,src=/tmp/aws_region \
            --secret id=backend_internal_url,src=/tmp/backend_internal_url \
            -t bhbaysinger/bb-portfolio-backend:dev ./backend
          rm -f /tmp/mongodb_uri /tmp/payload_secret /tmp/aws_access_key_id /tmp/aws_secret_access_key /tmp/ses_from_email /tmp/ses_to_email /tmp/smtp_from_email /tmp/public_server_url /tmp/frontend_url /tmp/s3_bucket /tmp/public_projects_bucket /tmp/nda_projects_bucket /tmp/aws_region /tmp/backend_internal_url
          echo "${SANITIZED_FE_REQ}" > /tmp/required_environment_variables_frontend
          echo "${{ secrets.BACKEND_INTERNAL_URL }}" > /tmp/backend_internal_url
          echo "${{ secrets.PUBLIC_PROJECTS_BUCKET }}" > /tmp/public_projects_bucket
          echo "${{ secrets.NDA_PROJECTS_BUCKET }}" > /tmp/nda_projects_bucket
          echo "${{ secrets.NEXT_PUBLIC_RUM_APP_MONITOR_ID }}" > /tmp/next_public_rum_app_monitor_id
          echo "${{ secrets.NEXT_PUBLIC_RUM_IDENTITY_POOL_ID }}" > /tmp/next_public_rum_identity_pool_id
          echo "${{ secrets.NEXT_PUBLIC_RUM_GUEST_ROLE_ARN }}" > /tmp/next_public_rum_guest_role_arn
          echo "${{ secrets.NEXT_PUBLIC_RUM_REGION }}" > /tmp/next_public_rum_region
          echo "${{ secrets.NEXT_PUBLIC_RUM_DEBUG }}" > /tmp/next_public_rum_debug
          DOCKER_BUILDKIT=1 docker build --build-arg ENV_PROFILE=dev \
            --secret id=required_environment_variables_frontend,src=/tmp/required_environment_variables_frontend \
            --secret id=backend_internal_url,src=/tmp/backend_internal_url \
            --secret id=public_projects_bucket,src=/tmp/public_projects_bucket \
            --secret id=nda_projects_bucket,src=/tmp/nda_projects_bucket \
            --secret id=next_public_rum_app_monitor_id,src=/tmp/next_public_rum_app_monitor_id \
            --secret id=next_public_rum_identity_pool_id,src=/tmp/next_public_rum_identity_pool_id \
            --secret id=next_public_rum_guest_role_arn,src=/tmp/next_public_rum_guest_role_arn \
            --secret id=next_public_rum_region,src=/tmp/next_public_rum_region \
            --secret id=next_public_rum_debug,src=/tmp/next_public_rum_debug \
            -t bhbaysinger/bb-portfolio-frontend:dev ./frontend
          rm -f /tmp/required_environment_variables_frontend /tmp/backend_internal_url /tmp/public_projects_bucket /tmp/nda_projects_bucket /tmp/next_public_rum_app_monitor_id /tmp/next_public_rum_identity_pool_id /tmp/next_public_rum_guest_role_arn /tmp/next_public_rum_region /tmp/next_public_rum_debug
          docker push bhbaysinger/bb-portfolio-backend:dev
          docker push bhbaysinger/bb-portfolio-frontend:dev

  # Deploy dev via reusable workflow
  deploy-dev:
    # Only run for dev branch pushes or manual runs targeted at the dev branch.
    # Avoids concurrent dev/prod redeploys when manually dispatching the workflow on main.
    if: github.ref == 'refs/heads/dev' || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/dev')
    needs: build-push-dev-images
    uses: ./.github/workflows/redeploy.yml
    secrets: inherit
    with:
      environment: dev
      start_dev: ${{ 'true' }}
      refresh_env: ${{ 'true' }} # Always regenerate .env files on dev for convenience while iterating
      restart_containers: ${{ 'true' }}
