#!/usr/bin/env tsx

/**
 * Generate terraform.tfvars from bundled GitHub secrets
 *
 * This script bundles .github-secrets.<scope>.private.json5 files (via merge-github-secrets.ts)
 * and emits terraform.tfvars with the appropriate values, ensuring a single source of truth.
 *
 * Usage: npx tsx deploy/scripts/generate-terraform-vars.ts [--secrets <path>] [--out <path>]
 *  - --secrets, -s: Optional path to a secrets JSON5 file (relative to repo root or absolute)
 *  - --out,     -o: Optional path to output terraform.tfvars (relative to repo root or absolute)
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

import { loadSecrets, SecretBundle } from "../../scripts/lib/secrets";
import { mergeGithubSecrets } from "../../scripts/merge-github-secrets";

// Resolve project root and CLI overrides
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Prefer the current working directory as the repo root, with a fallback to two levels up from this script
const cwd = process.cwd();
const fallbackRoot = path.resolve(__dirname, "..", "..");

function looksLikeRepoRoot(dir: string): boolean {
  // Heuristics: has a package.json and an infra folder
  try {
    return (
      fs.existsSync(path.join(dir, "package.json")) &&
      fs.existsSync(path.join(dir, "infra"))
    );
  } catch {
    return false;
  }
}

let projectRoot = looksLikeRepoRoot(cwd) ? cwd : fallbackRoot;

const args = process.argv.slice(2);
function getArg(longFlag: string, shortFlag: string): string | undefined {
  const iLong = args.indexOf(longFlag);
  const iShort = args.indexOf(shortFlag);
  const i = iLong !== -1 ? iLong : iShort;
  if (i !== -1 && args[i + 1] && !args[i + 1].startsWith("-"))
    return args[i + 1];
  return undefined;
}

function resolveFromRoot(p: string): string {
  return path.isAbsolute(p) ? p : path.join(projectRoot, p);
}

const secretsArg = getArg("--secrets", "-s");
const outArg = getArg("--out", "-o");

// Paths (with CLI overrides)
const secretsFile = secretsArg
  ? resolveFromRoot(secretsArg)
  : path.join(projectRoot, ".github-secrets.private.json5");
const terraformVarsFile = outArg
  ? resolveFromRoot(outArg)
  : path.join(projectRoot, "infra", "terraform.tfvars");

if (!secretsArg) {
  mergeGithubSecrets({ rootDir: projectRoot, quiet: true });
}

function generateTerraformVars(
  shared: SecretBundle,
  dev: SecretBundle,
  prod: SecretBundle,
): string {
  const sharedStrings = shared.strings;
  const devStrings = dev.strings;
  const prodStrings = prod.strings;

  // Get EC2 instance IP from environment variable (optional)
  // Note: This value is not currently used by terraform.tfvars generation.
  // We keep it for potential future interpolation, but do not hard-fail if missing.
  const ec2InstanceIp = process.env.EC2_INSTANCE_IP || "";
  if (!ec2InstanceIp) {
    console.warn(
      "‚ö†Ô∏è  EC2_INSTANCE_IP not set; proceeding without it (not required for tfvars generation)",
    );
  }

  // Base configuration (non-secret values)
  const baseConfig = `# =============================================================================
# Terraform Variables - Auto-generated from .github-secrets.<env>.private.json5
# =============================================================================
#
# This file is generated by scripts/generate-terraform-vars.ts
# DO NOT EDIT MANUALLY - changes will be overwritten
#
# To update values, edit the appropriate .github-secrets.<env>.private.json5 file(s), then run:
#   npm run secrets:bundle
#   npx tsx deploy/scripts/generate-terraform-vars.ts
# =============================================================================

# Infrastructure Configuration
region        = "us-west-2"
instance_type = "t3.micro"
key_name      = "bb-portfolio-site-key"
ami_id        = "ami-0cf2b4e024cdb6960" # Amazon Linux 2023 in us-west-2 (as of Sept 2025)
project_name  = "bb-portfolio"

`;

  // Environment variables from secrets
  const envVars = `# =============================================================================
# Environment Variables (bundled from per-environment secrets)
# =============================================================================

# AWS Configuration
aws_access_key_id     = "${sharedStrings.AWS_ACCESS_KEY_ID}"
aws_secret_access_key = "${sharedStrings.AWS_SECRET_ACCESS_KEY}"
prod_aws_region       = "${prodStrings.AWS_REGION || sharedStrings.AWS_REGION || ""}"

# Database Configuration
prod_mongodb_uri = "${prodStrings.MONGODB_URI}"

# Payload CMS Configuration
prod_payload_secret = "${prodStrings.PAYLOAD_SECRET}"

    # S3/Projects & Media Configuration
    public_projects_bucket = "${sharedStrings.PUBLIC_PROJECTS_BUCKET}"
    nda_projects_bucket = "${sharedStrings.NDA_PROJECTS_BUCKET}"

    # Media buckets for Payload CMS uploads (per environment)
    prod_s3_bucket = "${prodStrings.S3_BUCKET}"

# Frontend URLs
prod_frontend_url         = "${prodStrings.FRONTEND_URL}"
prod_backend_internal_url = "${prodStrings.BACKEND_INTERNAL_URL}"

# Email Configuration
prod_ses_from_email = "${prodStrings.SES_FROM_EMAIL}"
prod_ses_to_email   = "${prodStrings.SES_TO_EMAIL}"

# =============================================================================
# Development Environment Variables
# =============================================================================

# AWS Configuration
dev_aws_region = "${devStrings.AWS_REGION || sharedStrings.AWS_REGION || ""}"

# Database Configuration
dev_mongodb_uri = "${devStrings.MONGODB_URI}"

# Payload CMS Configuration
dev_payload_secret = "${devStrings.PAYLOAD_SECRET}"

  # Media bucket for Payload CMS uploads (dev environment)
  dev_s3_bucket = "${devStrings.S3_BUCKET}"

# Backend URLs
dev_backend_internal_url = "${devStrings.BACKEND_INTERNAL_URL}"

# Email Configuration
dev_ses_from_email = "${devStrings.SES_FROM_EMAIL}"
dev_ses_to_email   = "${devStrings.SES_TO_EMAIL}"

# =============================================================================
# HTTPS / ACME
# =============================================================================
acme_registration_email = "${sharedStrings.ACME_REGISTRATION_EMAIL || sharedStrings.ACME_EMAIL || ""}"
`;

  return baseConfig + envVars;
}

type SecretStrings = Record<string, string>;

function findMissingVariables(bundles: {
  shared: SecretStrings;
  dev: SecretStrings;
  prod: SecretStrings;
}): string[] {
  const { shared, dev, prod } = bundles;

  const hasValue = (bundle: SecretStrings, key: string) =>
    Boolean(bundle && bundle[key] && bundle[key].length > 0);

  const requirements: Array<{
    label: string;
    sources: Array<{ bundle: SecretStrings; key: string }>;
  }> = [
    {
      label: "aws_access_key_id",
      sources: [{ bundle: shared, key: "AWS_ACCESS_KEY_ID" }],
    },
    {
      label: "aws_secret_access_key",
      sources: [{ bundle: shared, key: "AWS_SECRET_ACCESS_KEY" }],
    },
    {
      label: "public_projects_bucket",
      sources: [{ bundle: shared, key: "PUBLIC_PROJECTS_BUCKET" }],
    },
    {
      label: "nda_projects_bucket",
      sources: [{ bundle: shared, key: "NDA_PROJECTS_BUCKET" }],
    },
    {
      label: "prod_aws_region",
      sources: [
        { bundle: prod, key: "AWS_REGION" },
        { bundle: shared, key: "AWS_REGION" },
      ],
    },
    {
      label: "prod_mongodb_uri",
      sources: [{ bundle: prod, key: "MONGODB_URI" }],
    },
    {
      label: "prod_payload_secret",
      sources: [{ bundle: prod, key: "PAYLOAD_SECRET" }],
    },
    {
      label: "prod_s3_bucket",
      sources: [{ bundle: prod, key: "S3_BUCKET" }],
    },
    {
      label: "prod_frontend_url",
      sources: [{ bundle: prod, key: "FRONTEND_URL" }],
    },
    {
      label: "prod_backend_internal_url",
      sources: [{ bundle: prod, key: "BACKEND_INTERNAL_URL" }],
    },
    {
      label: "prod_ses_from_email",
      sources: [{ bundle: prod, key: "SES_FROM_EMAIL" }],
    },
    {
      label: "prod_ses_to_email",
      sources: [{ bundle: prod, key: "SES_TO_EMAIL" }],
    },
    {
      label: "dev_aws_region",
      sources: [
        { bundle: dev, key: "AWS_REGION" },
        { bundle: shared, key: "AWS_REGION" },
      ],
    },
    {
      label: "dev_mongodb_uri",
      sources: [{ bundle: dev, key: "MONGODB_URI" }],
    },
    {
      label: "dev_payload_secret",
      sources: [{ bundle: dev, key: "PAYLOAD_SECRET" }],
    },
    {
      label: "dev_s3_bucket",
      sources: [{ bundle: dev, key: "S3_BUCKET" }],
    },
    {
      label: "dev_backend_internal_url",
      sources: [{ bundle: dev, key: "BACKEND_INTERNAL_URL" }],
    },
    {
      label: "dev_ses_from_email",
      sources: [{ bundle: dev, key: "SES_FROM_EMAIL" }],
    },
    {
      label: "dev_ses_to_email",
      sources: [{ bundle: dev, key: "SES_TO_EMAIL" }],
    },
  ];

  return requirements
    .filter((req) =>
      req.sources.every(({ bundle, key }) => !hasValue(bundle, key)),
    )
    .map((req) => req.label);
}

function main() {
  try {
    console.info(
      "üîÑ Generating terraform.tfvars from .github-secrets.private.json5...",
    );
    console.info("Project root:", projectRoot);
    console.info("Secrets file:", secretsFile);

    const secretsRoot = path.dirname(secretsFile);
    const sharedFileName = path.basename(secretsFile);

    const sharedSecrets = loadSecrets({
      rootDir: secretsRoot,
      sharedFile: sharedFileName,
    });
    const devSecrets = loadSecrets({
      profile: "dev",
      rootDir: secretsRoot,
      sharedFile: sharedFileName,
    });
    const prodSecrets = loadSecrets({
      profile: "prod",
      rootDir: secretsRoot,
      sharedFile: sharedFileName,
    });
    console.info("‚úÖ Loaded shared/dev/prod secret bundles");

    // Generate terraform vars content
    const terraformVarsContent = generateTerraformVars(
      sharedSecrets,
      devSecrets,
      prodSecrets,
    );

    // Ensure infra directory exists
    const infraDir = path.dirname(terraformVarsFile);
    if (!fs.existsSync(infraDir)) {
      fs.mkdirSync(infraDir, { recursive: true });
    }

    // Write terraform.tfvars file
    fs.writeFileSync(terraformVarsFile, terraformVarsContent);
    console.info("‚úÖ Generated terraform.tfvars");

    const missingVars = findMissingVariables({
      shared: sharedSecrets.strings,
      dev: devSecrets.strings,
      prod: prodSecrets.strings,
    });

    if (missingVars.length > 0) {
      console.warn("‚ö†Ô∏è  Missing required variables in secrets file:");
      missingVars.forEach((varName) =>
        console.warn(`   - ${varName.toUpperCase()}`),
      );
    } else {
      console.info("‚úÖ All required variables are present");
    }

    console.info("üéà terraform.tfvars generated successfully!");
    console.info(`üìÅ Location: ${terraformVarsFile}`);
  } catch (error) {
    console.error("‚ùå Error generating terraform.tfvars:", error);
    process.exit(1);
  }
}

// Run main function
main();
