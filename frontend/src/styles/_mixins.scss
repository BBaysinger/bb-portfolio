@use "sass:math";
@use "sass:map";
@use "sass:string";
@use "sass:meta";
@use "@/styles/variables" as *;

// Attribution: The responsive viewport lerp (linear interpolation) mixin system in this file
// is an original system designed by Bradley Baysinger for this website.

//////////////////////////////////////////////////////////////////////////
// Responsive Breakpoints
//////////////////////////////////////////////////////////////////////////

/// Mobile-first media query mixin
/// Usage: Apply styles starting from the specified breakpoint and up.
///
/// @example
/// .example {
///   @include breakpointUp($b768px) {
///     background-color: $lighterThemeColor;
///   }
/// }
@mixin breakpointUp($breakpoint) {
  $min-width: map.get($breakpoints, $breakpoint);
  @if $min-width != null {
    @media screen and (min-width: $min-width) {
      @content;
    }
  } @else {
    @media screen and (min-width: $breakpoint) {
      @content;
    }
  }
}

//////////////////////////////////////////////////////////////////////////
// Unit Helpers
//////////////////////////////////////////////////////////////////////////

/// Removes the unit from a numeric CSS value for use in calculations
@function stripUnit($value) {
  @return math.div($value, $value * 0 + 1);
}

/// Ensures a value has a specific unit
@function ensureUnit($value, $unit) {
  @if meta.type-of($value) != "number" {
    @error "ensureUnit() expected a number, got: #{meta.inspect($value)}";
  }

  @if not math.is-unitless($value) {
    @return $value; // already has a unit
  }

  @if $unit == "px" {
    @return $value * 1px;
  } @else if $unit == "vw" {
    @return $value * 1vw;
  } @else if $unit == "rem" {
    @return $value * 1rem;
  } @else {
    @error "Unknown unit passed to ensureUnit(): `#{$unit}`";
  }
}

/// Converts pixel values to rems
/// @param $px - Pixel value
/// @param $base - Root font size (default: 16px)
/// @return rem-converted value
@function to-rems($value, $base: 16px) {
  $unit: math.unit($value);

  @if $unit == "px" {
    @return math.div($value, $base) * 1rem;
  } @else if $unit == "rem" {
    @return $value;
  } @else if $unit == "" {
    @return $value * 1rem;
  } @else {
    // fallback: convert to rem based on base font size
    @warn "to-rems(): Unsupported unit '#{$unit}'. Returning unconverted.";
    @return $value;
  }
}

/// Rounds a number to a given number of decimal places
@function rnd($number, $places: 0) {
  $n: 1;
  @if $places > 0 {
    @for $i from 1 through $places {
      $n: $n * 10;
    }
  }
  @return math.div(math.round($number * $n), $n);
}

//////////////////////////////////////////////////////////////////////////
// SVG Trickery
//////////////////////////////////////////////////////////////////////////

/// Builds a minimal inline SVG data URL for background or masking
/// Assumes path is scaled to a 1in x 1in viewbox
///
/// @example
/// mask-image: svg("M0,0v72h72V0H0Z");
@function svg($d, $color: #fff) {
  $color-string: "";
  @if meta.type-of($color) == "string" {
    $color-string: $color;
  } @else {
    $color-string: "#{$color}";
  }

  $formatted-color: $color-string;
  @if string.index($color-string, "#") == 1 {
    $formatted-color: "%23#{string.slice($color-string, 2)}";
  }

  @return string.unquote(
    "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' " +
      "viewBox='0 0 72 72'%3E%3Cpath d='#{$d}' fill='#{$formatted-color}'/%3E%3C/svg%3E\")"
  );
}

//////////////////////////////////////////////////////////////////////////
// UI Animation Pausing Utilities
//////////////////////////////////////////////////////////////////////////

/// Pauses animations when the hero is in view
@mixin pauseWhenHeroVisible {
  animation-play-state: running;

  :global(.isHeroInView100Pct) & {
    animation-play-state: paused !important;
  }
}

/// Resumes nav animations when the mobile nav is expanded
/// KEEP: This will pause animations in the nav.
// @mixin pauseUnlessMobileNavExpanded {
//   animation-play-state: paused;

//   :global(.isMobileNavExpanded) & {
//     animation-play-state: running !important;
//   }
// }

//////////////////////////////////////////////////////////////////////////
// Responsive Viewport Lerp (Linear Interpolation) with Custom Properties
//////////////////////////////////////////////////////////////////////////

/// Returns a CSS custom-property reference for the viewport lerp factor $t$
///
/// This is the core primitive for the custom-property-based fluid system.
/// The referenced CSS variable represents a normalized lerp (linear interpolation) factor $t$
/// (typically 0 → 1) for a specific viewport range.
///
/// Note: This function only returns a `var(...)` reference. The underlying `--lerp-percent-*`
/// variable is set by `useLerpVars` (JavaScript) on an ancestor element. Until JS runs
/// (or if the hook is not used), the fallback value is used.
///
/// Conceptually (viewport → $t$):
/// - `t = 0` at the minimum viewport width
/// - `t = 1` at the maximum viewport width
/// - values between are a linear interpolation of the viewport position
///
/// The scaling formula used elsewhere is:
/// `value = min + (max - min) * t`
///
/// @example
/// percent-var(360, 1440) => var(--lerp-percent-360-1440, 0)
@function percent-var($min, $max) {
  $min-stripped: stripUnit($min);
  $max-stripped: stripUnit($max);
  @return string.unquote(
    // Provide a 0 fallback so before `useLerpVars` initializes variables,
    // the interpolation factor resolves to 0 and components render at their min size.
    "var(--lerp-percent-#{$min-stripped}-#{$max-stripped}, 0)"
  );
}

/// Applies accessibility-friendly fluid scaling via a shared viewport lerp factor (custom properties)
///
/// **Requires useLerpVars hook** to provide CSS variables like `--lerp-percent-320-640`.
/// Internally this is a lerp (linear interpolation): `min + (max - min) * t` where `t` comes from `percent-var()`.
/// Values are converted to `rem` for accessibility so they respect user font-size preferences.
///
/// Use for: Typography, UI elements, text-related spacing
/// Don't use for: Fixed layouts, images, precise visual spacing (use lerpRange instead)
///
/// @param $property - The CSS property to scale
/// @param $min-value - Value at minimum viewport width (px or rem)
/// @param $max-value - Value at maximum viewport width (px or rem)
/// @param $min-vw - Minimum viewport width (must match useLerpVars range)
/// @param $max-vw - Maximum viewport width (must match useLerpVars range)
///
/// @example Setup useLerpVars hook first:
/// const fluidRef = useLerpVars([[360, 1440]]);
///
/// @example SCSS usage:
/// @include remRange(font-size, 16px, 24px, 360, 1440);
@mixin remRange(
  $property,
  $min-value,
  $max-value,
  $min-vw: $b320,
  $max-vw: $b1792
) {
  $min-rem: to-rems($min-value);
  $max-rem: to-rems($max-value);

  @if math.unit($min-rem) != "rem" or math.unit($max-rem) != "rem" {
    @warn "remRange(): Values are not in px/rem. Falling back to unconverted interpolation.";
    #{$property}: calc(
      #{$min-value} +
        (
          #{stripUnit($max-value - $min-value)} *
            #{percent-var($min-vw, $max-vw)}
        )
    );
  } @else {
    $range: rnd($max-rem - $min-rem, 4);
    $percent-var: percent-var($min-vw, $max-vw);
    #{$property}: calc(#{$min-rem} + #{$range} * #{$percent-var});
  }
}

/// Applies pixel-precise fluid scaling using media queries with linear interpolation
///
/// **Independent of useLerpVars** - generates pure CSS with media queries.
/// Maintains exact unit precision without converting to rem. Ideal for layouts and visual elements
/// that should scale with viewport, not user font preferences.
///
/// Internally this is the same lerp (linear interpolation) idea, but the interpolation factor is computed
/// directly from `100vw` instead of coming from a shared custom property.
///
/// Use for: Container dimensions, layout spacing, visual components, grid gaps
/// Don't use for: Typography, UI elements that should respect font size (use remRange instead)
///
/// @param $property - The CSS property to scale (e.g. `width`, `margin-top`)
/// @param $min-value - Value at minimum viewport (any unit: px, em, %)
/// @param $max-value - Value at maximum viewport (same unit as min-value)
/// @param $min-vw - Minimum viewport width (px or unitless, default: $b320)
/// @param $max-vw - Maximum viewport width (px or unitless, default: $b1792)
///
/// @example Container scaling:
/// @include lerpRange(width, 300px, 1200px, 320, 1440);
///
/// @example Visual spacing:
/// @include lerpRange(gap, 16px, 48px, 320, 768);
@mixin lerpRange(
  $property,
  $min-value,
  $max-value,
  $min-vw: $b320,
  $max-vw: $b1792
) {
  // Normalize viewports first — allow unitless values like 320 → 320px
  $min-vw: ensureUnit($min-vw, "px");
  $max-vw: ensureUnit($max-vw, "px");

  // Normalize value units (still allow unitless values if needed — optional!)
  $min-value: ensureUnit($min-value, math.unit($max-value));
  $max-value: ensureUnit($max-value, math.unit($min-value));

  // Extract units for validation
  $unit-min-vw: math.unit($min-vw);
  $unit-max-vw: math.unit($max-vw);
  $unit-min-value: math.unit($min-value);
  $unit-max-value: math.unit($max-value);

  // Ensure consistent units
  @if $unit-min-vw != $unit-max-vw {
    @error "Viewport units must match. Got: #{$unit-min-vw} and #{$unit-max-vw}";
  }
  @if $unit-min-value != $unit-max-value {
    @error "Value units must match. Got: #{$unit-min-value} and #{$unit-max-value}";
  }

  // Set the base value
  #{$property}: $min-value;

  // Firefox currently rejects `calc()` expressions that divide a length by a length
  // (e.g. `(100vw - 320px) / 1472px`), which caused all lerped declarations to be dropped.
  //
  // Approach:
  // - If the interpolation slope is unitless (e.g., px over px), precompute it in Sass and
  //   use a CSS expression that only multiplies a number by a length.
  // - Otherwise (e.g., % values), fall back to the JS-provided `--lerp-percent-*` vars.
  $vw-range: $max-vw - $min-vw;
  $value-range: $max-value - $min-value;
  $slope: math.div($value-range, $vw-range);

  @if math.unit($slope) == "" {
    // Pure CSS, smooth, and Firefox-safe.
    @media screen and (min-width: $min-vw) {
      #{$property}: calc(#{$min-value} + #{$slope} * (100vw - #{$min-vw}));
    }
    @media screen and (min-width: $max-vw) {
      #{$property}: $max-value;
    }
  } @else {
    // Cross-unit values (e.g., %) can't safely use the slope form in CSS.
    // Use the clamped, unitless lerp factor set by `useLerpVars`.
    $t: percent-var($min-vw, $max-vw);
    #{$property}: calc(#{$min-value} + (#{$value-range}) * #{$t});

    // Even if the JS vars are missing, still snap to max at the upper breakpoint.
    @media screen and (min-width: $max-vw) {
      #{$property}: $max-value;
    }
  }
}

//////////////////////////////////////////////////////////////////////////
// Transform Scaling
//////////////////////////////////////////////////////////////////////////

/// Applies smooth transform scaling using a clamp-bounded lerp (linear interpolation)
///
/// This mixin uses `clamp()` as a guard rail around a viewport-based lerp (linear interpolation)
/// and injects the result into `transform: scale(...)`.
///
/// In other words: it’s a responsive, transform-specific lerp expression
/// bounded by `clamp(min, preferred, max)` — not a simple `clamp()` between two fixed
/// values like you’d commonly do for `font-size`.
///
/// IMPORTANT: Firefox still rejects `calc()`/`clamp()` inside `scale()`, so the `transform`
/// declaration generated here may be ignored in Gecko and fall back to a previous valid
/// `transform` declaration. Components that rely on this mixin should provide a non-CSS
/// fallback (e.g., JS-driven scaling) if they need responsive scale on Firefox.
///
/// **Independent of useLerpVars** - generates pure CSS and stays perfectly smooth.
/// Combines with existing transforms and provides pixel-perfect responsive scaling.
///
/// Use for: Component scaling, zoom effects, responsive animations
/// Advantage: No media query jumps - perfectly smooth across all viewport sizes
///
/// @param $min-scale - Scale value at minimum viewport (unitless number, e.g. 0.8)
/// @param $max-scale - Scale value at maximum viewport (unitless number, e.g. 1.2)
/// @param $min-vw - Minimum viewport width (px or unitless, default: $b320)
/// @param $max-vw - Maximum viewport width (px or unitless, default: $b1792)
/// @param $preserve-transform - Existing transform functions to preserve (default: null)
///
/// @example Basic scaling:
/// @include scaleRange(0.8, 1.2, 320, 1280);
///
/// @example Preserve centering:
/// @include scaleRange(0.9, 1.0, 320, 768, translateX(-50%) translateY(-50%));
@mixin scaleRange(
  $min-scale,
  $max-scale,
  $min-vw: $b320,
  $max-vw: $b1792,
  $preserve-transform: null
) {
  // Normalize viewports
  $min-vw: ensureUnit($min-vw, "px");
  $max-vw: ensureUnit($max-vw, "px");

  // Validate scale values are unitless numbers
  @if math.unit($min-scale) != "" {
    @error "scaleRange(): Scale values must be unitless. Got: #{$min-scale}";
  }
  @if math.unit($max-scale) != "" {
    @error "scaleRange(): Scale values must be unitless. Got: #{$max-scale}";
  }

  // Build transform with clamp()-bounded lerp.
  // IMPORTANT: See note about Firefox support above.
  $base-transform: "";
  @if $preserve-transform {
    $base-transform: "#{$preserve-transform} ";
  }
  $range: $max-scale - $min-scale;
  $vw-range: stripUnit($max-vw - $min-vw);

  transform: string.unquote(
    "#{$base-transform}scale(clamp(#{$min-scale}, #{$min-scale} + #{$range} * ((100vw - #{$min-vw}) / #{$vw-range}px), #{$max-scale}))"
  );
}
