@use "sass:math";
@use "sass:map";
@use "sass:string";
@use "sass:meta";
@use "@/styles/variables" as *;

//////////////////////////////////////////////////////////////////////////
// Responsive Breakpoints
//////////////////////////////////////////////////////////////////////////

/// Mobile-first media query mixin
/// Usage: Apply styles starting from the specified breakpoint and up.
///
/// @example
/// .example {
///   @include breakpointUp($b768px) {
///     background-color: $lighterThemeColor;
///   }
/// }
@mixin breakpointUp($breakpoint) {
  $min-width: map.get($breakpoints, $breakpoint);
  @if $min-width != null {
    @media screen and (min-width: $min-width) {
      @content;
    }
  } @else {
    @media screen and (min-width: $breakpoint) {
      @content;
    }
  }
}

//////////////////////////////////////////////////////////////////////////
// Unit Helpers
//////////////////////////////////////////////////////////////////////////

/// Removes the unit from a numeric CSS value for use in calculations
@function stripUnit($value) {
  @return math.div($value, $value * 0 + 1);
}

/// Ensures a value has a specific unit
@function ensureUnit($value, $unit) {
  @if meta.type-of($value) != "number" {
    @error "ensureUnit() expected a number, got: #{meta.inspect($value)}";
  }

  @if not math.is-unitless($value) {
    @return $value; // already has a unit
  }

  @if $unit == "px" {
    @return $value * 1px;
  } @else if $unit == "vw" {
    @return $value * 1vw;
  } @else if $unit == "rem" {
    @return $value * 1rem;
  } @else {
    @error "Unknown unit passed to ensureUnit(): `#{$unit}`";
  }
}

/// Converts pixel values to rems
/// @param $px - Pixel value
/// @param $base - Root font size (default: 16px)
/// @return rem-converted value
@function to-rems($value, $base: 16px) {
  $unit: math.unit($value);

  @if $unit == "px" {
    @return math.div($value, $base) * 1rem;
  } @else if $unit == "rem" {
    @return $value;
  } @else if $unit == "" {
    @return $value * 1rem;
  } @else {
    // fallback: convert to rem based on base font size
    @warn "to-rems(): Unsupported unit '#{$unit}'. Returning unconverted.";
    @return $value;
  }
}

/// Rounds a number to a given number of decimal places
@function rnd($number, $places: 0) {
  $n: 1;
  @if $places > 0 {
    @for $i from 1 through $places {
      $n: $n * 10;
    }
  }
  @return math.div(math.round($number * $n), $n);
}

//////////////////////////////////////////////////////////////////////////
// SVG Trickery
//////////////////////////////////////////////////////////////////////////

/// Builds a minimal inline SVG data URL for background or masking
/// Assumes path is scaled to a 1in x 1in viewbox
///
/// @example
/// mask-image: svg("M0,0v72h72V0H0Z");
@function svg($d, $color: #fff) {
  $color-string: if(meta.type-of($color) == "string", $color, "#{$color}");
  $formatted-color: if(
    string.index($color-string, "#") == 1,
    "%23#{string.slice($color-string, 2)}",
    $color-string
  );

  @return string.unquote(
    "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' " +
      "viewBox='0 0 72 72'%3E%3Cpath d='#{$d}' fill='#{$formatted-color}'/%3E%3C/svg%3E\")"
  );
}

//////////////////////////////////////////////////////////////////////////
// UI Animation Pausing Utilities
//////////////////////////////////////////////////////////////////////////

/// Pauses animations when the hero is in view
@mixin pauseWhenHeroVisible {
  animation-play-state: running;

  :global(.isHeroInView100Pct) & {
    animation-play-state: paused !important;
  }
}

/// Resumes nav animations when the mobile nav is expanded
/// KEEP: This will pause animations in the nav.
// @mixin pauseUnlessMobileNavExpanded {
//   animation-play-state: paused;

//   :global(.isMobileNavExpanded) & {
//     animation-play-state: running !important;
//   }
// }

//////////////////////////////////////////////////////////////////////////
// Fluid Scaling with Custom Properties
//////////////////////////////////////////////////////////////////////////

/// Generates a CSS variable reference like var(--fluid-percent-360-1440)
@function percent-var($min, $max) {
  $min-stripped: stripUnit($min);
  $max-stripped: stripUnit($max);
  @return string.unquote(
    "var(--fluid-percent-#{$min-stripped}-#{$max-stripped})"
  );
}

/// Applies accessibility-friendly fluid scaling using CSS custom properties
///
/// **Requires useFluidVariables hook** to provide CSS variables like `--fluid-percent-320-680`.
/// Converts values to rem units for accessibility - scales with user font preferences.
///
/// Use for: Typography, UI elements, text-related spacing
/// Don't use for: Fixed layouts, images, precise visual spacing (use staticRange instead)
///
/// @param $property - The CSS property to scale
/// @param $min-value - Value at minimum viewport width (px or rem)
/// @param $max-value - Value at maximum viewport width (px or rem)
/// @param $min-vw - Minimum viewport width (must match useFluidVariables range)
/// @param $max-vw - Maximum viewport width (must match useFluidVariables range)
///
/// @example Setup useFluidVariables hook first:
/// const fluidRef = useFluidVariables([[360, 1440]]);
///
/// @example SCSS usage:
/// @include remRange(font-size, 16px, 24px, 360, 1440);
@mixin remRange(
  $property,
  $min-value,
  $max-value,
  $min-vw: $b320,
  $max-vw: $b1600
) {
  $min-rem: to-rems($min-value);
  $max-rem: to-rems($max-value);

  @if math.unit($min-rem) != "rem" or math.unit($max-rem) != "rem" {
    @warn "remRange(): Values are not in px/rem. Falling back to unconverted interpolation.";
    #{$property}: calc(
      #{$min-value} +
        (
          #{stripUnit($max-value - $min-value)} *
            #{percent-var($min-vw, $max-vw)}
        )
    );
  } @else {
    $range: rnd($max-rem - $min-rem, 4);
    $percent-var: percent-var($min-vw, $max-vw);
    #{$property}: calc(#{$min-rem} + #{$range} * #{$percent-var});
  }
}

/// Applies pixel-precise fluid scaling using media queries with linear interpolation
///
/// **Independent of useFluidVariables** - generates pure CSS with media queries.
/// Maintains exact unit precision without converting to rem. Ideal for layouts and visual elements
/// that should scale with viewport, not user font preferences.
///
/// Use for: Container dimensions, layout spacing, visual components, grid gaps
/// Don't use for: Typography, UI elements that should respect font size (use remRange instead)
///
/// @param $property - The CSS property to scale (e.g. `width`, `margin-top`)
/// @param $min-value - Value at minimum viewport (any unit: px, em, %)
/// @param $max-value - Value at maximum viewport (same unit as min-value)
/// @param $min-vw - Minimum viewport width (px or unitless, default: $b320)
/// @param $max-vw - Maximum viewport width (px or unitless, default: $b1600)
///
/// @example Container scaling:
/// @include staticRange(width, 300px, 1200px, 320, 1440);
///
/// @example Visual spacing:
/// @include staticRange(gap, 16px, 48px, 320, 768);
@mixin staticRange(
  $property,
  $min-value,
  $max-value,
  $min-vw: $b320,
  $max-vw: $b1600
) {
  // Normalize viewports first — allow unitless values like 320 → 320px
  $min-vw: ensureUnit($min-vw, "px");
  $max-vw: ensureUnit($max-vw, "px");

  // Normalize value units (still allow unitless values if needed — optional!)
  $min-value: ensureUnit($min-value, math.unit($max-value));
  $max-value: ensureUnit($max-value, math.unit($min-value));

  // Extract units for validation
  $unit-min-vw: math.unit($min-vw);
  $unit-max-vw: math.unit($max-vw);
  $unit-min-value: math.unit($min-value);
  $unit-max-value: math.unit($max-value);

  // Ensure consistent units
  @if $unit-min-vw != $unit-max-vw {
    @error "Viewport units must match. Got: #{$unit-min-vw} and #{$unit-max-vw}";
  }
  @if $unit-min-value != $unit-max-value {
    @error "Value units must match. Got: #{$unit-min-value} and #{$unit-max-value}";
  }

  // Set the base value
  & {
    #{$property}: $min-value;
  }

  // Interpolate between min and max across the viewport range
  @media screen and (min-width: $min-vw) {
    #{$property}: calc(
      #{$min-value} +
        (
          #{stripUnit($max-value - $min-value)} *
            ((100vw - #{$min-vw}) / #{stripUnit($max-vw - $min-vw)})
        )
    );
  }

  // Set the maximum value explicitly
  @media screen and (min-width: $max-vw) {
    #{$property}: $max-value;
  }
}

//////////////////////////////////////////////////////////////////////////
// Transform Scaling
//////////////////////////////////////////////////////////////////////////

/// Applies smooth transform scaling using clamp() for linear interpolation without jumps
///
/// **Independent of useFluidVariables** - uses clamp() for truly smooth scaling.
/// Combines with existing transforms and provides pixel-perfect responsive scaling.
///
/// Use for: Component scaling, zoom effects, responsive animations
/// Advantage: No media query jumps - perfectly smooth across all viewport sizes
///
/// @param $min-scale - Scale value at minimum viewport (unitless number, e.g. 0.8)
/// @param $max-scale - Scale value at maximum viewport (unitless number, e.g. 1.2)
/// @param $min-vw - Minimum viewport width (px or unitless, default: $b320)
/// @param $max-vw - Maximum viewport width (px or unitless, default: $b1600)
/// @param $preserve-transform - Existing transform functions to preserve (default: null)
///
/// @example Basic scaling:
/// @include scaleRange(0.8, 1.2, 320, 1280);
///
/// @example Preserve centering:
/// @include scaleRange(0.9, 1.0, 320, 768, translateX(-50%) translateY(-50%));
@mixin scaleRange(
  $min-scale,
  $max-scale,
  $min-vw: $b320,
  $max-vw: $b1600,
  $preserve-transform: null
) {
  // Normalize viewports
  $min-vw: ensureUnit($min-vw, "px");
  $max-vw: ensureUnit($max-vw, "px");

  // Validate scale values are unitless numbers
  @if math.unit($min-scale) != "" {
    @error "scaleRange(): Scale values must be unitless. Got: #{$min-scale}";
  }
  @if math.unit($max-scale) != "" {
    @error "scaleRange(): Scale values must be unitless. Got: #{$max-scale}";
  }

  // Build transform with clamp - generate the exact working syntax
  $base-transform: if($preserve-transform, "#{$preserve-transform} ", "");
  $range: $max-scale - $min-scale;
  $vw-range: stripUnit($max-vw - $min-vw);

  transform: string.unquote(
    "#{$base-transform}scale(clamp(#{$min-scale}, #{$min-scale} + #{$range} * ((100vw - #{$min-vw}) / #{$vw-range}px), #{$max-scale}))"
  );
}
