@use "sass:math";
@use "sass:map";
@use "sass:string";
@use "@/styles/variables" as *;

//////////////////////////////////////////////////////////////////////////
// Responsive Breakpoints
//////////////////////////////////////////////////////////////////////////

/// Mobile-first media query mixin
/// Usage: Apply styles starting from the specified breakpoint and up.
///
/// @example
/// .example {
///   @include breakpointUp($b768px) {
///     background-color: $lighterThemeColor;
///   }
/// }
@mixin breakpointUp($breakpoint) {
  $min-width: map.get($breakpoints, $breakpoint);
  @if $min-width != null {
    @media screen and (min-width: $min-width) {
      @content;
    }
  } @else {
    @media screen and (min-width: $breakpoint) {
      @content;
    }
  }
}

//////////////////////////////////////////////////////////////////////////
// Unit Helpers
//////////////////////////////////////////////////////////////////////////

/// Removes the unit from a numeric CSS value for use in calculations
@function strip-unit($value) {
  @return math.div($value, ($value * 0 + 1));
}

/// Converts pixel values to rems
/// @param $px - Pixel value
/// @param $base - Root font size (default: 16px)
/// @return rem-converted value
@function to-rems($px, $base: 16px) {
  @return math.div($px, $base) * 1rem;
}

/// Rounds a number to a given number of decimal places
@function rnd($number, $places: 0) {
  $n: 1;
  @if $places > 0 {
    @for $i from 1 through $places {
      $n: $n * 10;
    }
  }
  @return math.div(math.round($number * $n), $n);
}

//////////////////////////////////////////////////////////////////////////
// SVG Trickery
//////////////////////////////////////////////////////////////////////////

/// Builds a minimal inline SVG data URL for background or masking
/// Assumes path is scaled to a 1in x 1in viewbox
///
/// @example
/// mask-image: svg("M0,0v72h72V0H0Z");
@function svg($d, $color: #fff) {
  $color-string: if(meta.type-of($color) == "string", $color, "#{$color}");
  $formatted-color: if(
    string.index($color-string, "#") == 1,
    "%23#{string.slice($color-string, 2)}",
    $color-string
  );

  @return string.unquote(
    "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' " +
      "viewBox='0 0 72 72'%3E%3Cpath d='#{$d}' fill='#{$formatted-color}'/%3E%3C/svg%3E\")"
  );
}

//////////////////////////////////////////////////////////////////////////
// UI Animation Pausing Utilities
//////////////////////////////////////////////////////////////////////////

/// Pauses animations when the hero is in view
@mixin pauseWhenHeroVisible {
  animation-play-state: running;

  :global(.isHeroInView) & {
    animation-play-state: paused !important;
  }
}

/// Resumes nav animations when the mobile nav is expanded
@mixin pauseUnlessMobileNavExpanded {
  animation-play-state: paused;

  :global(.isMobileNavExpanded) & {
    animation-play-state: running !important;
  }
}

//////////////////////////////////////////////////////////////////////////
// Fluid Scaling with Custom Properties
//////////////////////////////////////////////////////////////////////////

/// Generates a CSS variable reference like var(--fluid-percent-360-1440)
@function percent-var($min, $max) {
  $min-unitless: strip-unit($min);
  $max-unitless: strip-unit($max);
  @return string.unquote(
    "var(--fluid-percent-#{$min-unitless}-#{$max-unitless})"
  );
}

/// Applies a fluidly scaled CSS property using CSS custom properties
/// Values will interpolate between min and max across a viewport range
///
/// @param $property - The CSS property to scale
/// @param $min-px - The value at the smallest viewport width
/// @param $max-px - The value at the largest viewport width
/// @param $min-vw - The minimum viewport width (default: $b320)
/// @param $max-vw - The maximum viewport width (default: $b1600)
///
/// @example
/// @include remScaler(font-size, 16px, 48px, 360, 1440);
@mixin remScaler($property, $min-px, $max-px, $min-vw: $b320, $max-vw: $b1600) {
  $min-rem: rnd(to-rems($min-px), 4);
  $max-rem: rnd(to-rems($max-px), 4);
  $range: rnd($max-rem - $min-rem, 4);
  $percent-var: percent-var($min-vw, $max-vw);

  #{$property}: calc(#{$min-rem} + #{$range} * #{$percent-var});
}

/// Applies a fluid CSS property using native `calc()` math directly in the rule.
///
/// This mixin does not rely on `rem` or custom properties. Instead, it linearly
/// interpolates a CSS value (e.g. `px`, `em`, `%`, etc.) between a minimum and
/// maximum viewport width. This is ideal when you want to keep your scaling unit
/// consistent (like pixel precision or em spacing) and avoid dependency on root font size.
///
/// @param $property - The CSS property to scale (e.g. `margin-top`)
/// @param $min-px - The value at the minimum viewport width (in px or unit you want)
/// @param $max-px - The value at the maximum viewport width (same unit as $min-px)
/// @param $min-vw - Minimum viewport width in px or unitless (default: $b320)
/// @param $max-vw - Maximum viewport width in px or unitless (default: $b1600)
///
/// @example
/// @include rangeStatic(letter-spacing, 0.02em, 0.12em, 360, 1440);
/// @include rangeStatic(width, 120px, 360px); // defaults to 320â€“1600px viewport
@mixin staticRange(
  $property,
  $min-px,
  $max-px,
  $min-vw: $b320,
  $max-vw: $b1600
) {
  $min-unitless-vw: strip-unit($min-vw);
  $max-unitless-vw: strip-unit($max-vw);
  $min-unit: math.unit($min-px);
  $max-unit: math.unit($max-px);

  @if $min-unit != $max-unit {
    @error "Units must match for $property: got #{$min-unit} and #{$max-unit}";
  }

  & {
    #{$property}: $min-px;
  }

  @media screen and (min-width: #{$min-unitless-vw}px) {
    #{$property}: calc(
      #{$min-px} + #{strip-unit($max-px - $min-px)}#{$min-unit} *
        (
          (100vw - #{$min-unitless-vw}px) /
            #{strip-unit($max-unitless-vw - $min-unitless-vw)}
        )
    );
  }

  @media screen and (min-width: #{$max-unitless-vw}px) {
    #{$property}: $max-px;
  }
}
